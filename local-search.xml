<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[OSDI论文阅读] Harvesting Memory-bound CPU Stall Cycles  in Software with MSH</title>
    <link href="/2024/07/11/osdi-memory-stall/"/>
    <url>/2024/07/11/osdi-memory-stall/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在经典论文 <a href="https://rcs.uwaterloo.ca/~ali/cs854-f23/papers/topdown.pdf">A Top-Down Method for Performance Analysis and Counters Architecture</a> 里，Ahmad Yasin提出了一种Top-Down的方法，基于微架构分析软件性能，把CPU流水线划分为4个部分：</p><ul><li><p>Frontend Bound, CPU流水线的前端部分(instruction fetch，指令解析等)，由i-cache miss, i-TLB miss等原因造成；</p></li><li><p>Bad Speculation，投机失败导致的流水线被浪费，如分支预测错误情况；</p></li><li><p>Retiring 即正常结束的指令，理论上越高代表程序性能越好；</p></li><li><p>Backend bound 流水线后端部分，可分为Core Bound和Memory Bound，前者偏向于计算单元，后边偏向于由内存访问导致的执行停顿。<br><img src="/img/top-down-hierarchy.png" alt="top-down"></p></li></ul><p>本文分析sphinx和masstree软件性能后，发现Memory Bound对两个软件的性能影响最大，在总cycle中的占比分别为25%和31%。</p><p><img src="/img/msh-topdown.png" alt="msh-topdown"></p><p>常见的降低Memory-bound Stall Cycles的解决方法为SMT(simultaneous multithreading)，即在一个物理核里有两个线程，共享一部分资源(ALU, FPU, cache等)，当其中一个线程发生Memory-bound时，另一个线程便可以利用这些共享的单元，提高流水线的利用率。然而SMT技术也存在不足，比如不可配置，如给定一个SLO，无法在Primaries的延迟和Scavengers的吞吐量之间进行权衡；此外，SMT 也无法完全捕获受Memory Bound导致的的stall cycle，尤其是当并发线程频繁发生cache miss时。这是因为主流的 2 宽度 SMT 没有足够的并发度来捕获大部分Memory stall，虽然可以通过 SMT 的宽度来解决此问题，但需要增加更多硬件资源，而且还加剧了延迟开销问题。</p><p>于是文章提出了一种名为MSH (Memory Stall Harvesting)的软件技术，利用Memory Bound导致的CPU stall cycle来执行额外的指令，针对SMT在Memory Bound方面的不足，用巧妙的软件设计降低了Memory Stall数量。</p><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>文章中高频出现两个词，在此做一下解释：</p><ul><li>Primaries，指主程序；</li><li>Scavengers，清理程序，主程序的协程，在特定时机（如mem stall）切换到清理程序执行。</li></ul><p>MSH设计可分为3部分：</p><ul><li><p>Profile</p></li><li><p>Binary Instrument</p></li><li><p>Runtime Scheduling<br>整体流程如下图：<br><img src="/img/msh-overview.png" alt="msh-overview"></p></li></ul><h3 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h3><p>首先在离线阶段使用性能剖析工具 (本文使用PEBS, LBR, perf)对程序进行性能分析，针对Load指令导致的Memory-bound进行评估，主要考虑L2&#x2F;L3 cache misses率以及代码块的执行次数。根据以下2条逻辑选取符合条件的Load指令：</p><ul><li><p>筛选cache miss率高于阈值的Load指令</p></li><li><p>通过如下公式来评估一条Load指令开销：</p><p>$$<br>Latency Overhead&#x3D;Instruction Frequency×Cache Miss Rate×Memory Access Latency<br>$$</p></li></ul><h3 id="Binary-Instrument"><a href="#Binary-Instrument" class="headerlink" title="Binary Instrument"></a>Binary Instrument</h3><p>即二进制插桩，MSH会在程序二进制中适当位置插入指令，对Primary和Scavengers都需要进行插桩。</p><h4 id="Primary-instrumentation"><a href="#Primary-instrumentation" class="headerlink" title="Primary instrumentation"></a>Primary instrumentation</h4><p>完成Profile后，在选取出来的Load指令前插入一条software prefetch指令，以及一条yield指令。在Runtime阶段，遇到开销较大的Load指令时，由于已经提前做了插桩操作，会将Load访问的地址预取到cache中，同时切换到scavengers线程执行，待合适时机再切换会primary线程，此时cache预取已完成，数据已经在cache中了，就不会导致memory stall出现影响性能。</p><h4 id="Scavenger-instrumentation"><a href="#Scavenger-instrumentation" class="headerlink" title="Scavenger instrumentation"></a>Scavenger instrumentation</h4><p>Scavenger插桩和Primary 方法相同，都是基于Profile的结果，在Load之前插入yield指令，并切换回Primary。有所不同的是，如果两个yield点过于靠近，第二条yield指令会切换到另一个Scavenger程序，而不是Primary。这是因为如果两条yield指令过于靠近，此时Primary的cache prefetch都还没完成，切换回去会导致memory stall，因此切换到另一个Scanvenger程序来避免此问题。</p><p>此外，由于协程切换需要保存上下文，为了减少这部分开销，MSH对循环的代码做了优化，仅对会发生修改的寄存器进行保存恢复操作，例如下图中的循环体中未操作R3和R4寄存器，因此在Loop body里进行协程切换时无需对这两个寄存器进行保存和恢复。</p><p> <img src="/img/msh-opt.png" alt="msh-opt"></p><h3 id="Runtime-Scheduling"><a href="#Runtime-Scheduling" class="headerlink" title="Runtime Scheduling"></a>Runtime Scheduling</h3><p>基于以上的分析，MSH必然还涉及Primary和多个Scanvenger的调度，线程管理，资源分配等问题。主要包含如下流程：</p><ul><li><p>Scanvenger初始化，在分配Scanvenger给Primary之前，会对Scanvenger进行初始化，包括加载Scanvenger代码，申请栈空间，设置返回地址。</p></li><li><p>Scanvenger窃取，在给Primary分配一个Scanvenger前，会优先从其他Primary那里窃取Scanvenger，避免重新建立一个新的Scanvenger带来开销。之所以可以被窃取，是由于在线程阻塞或者被终止时会被设置stealable的标志位。</p></li><li><p>Scanvenger获取，当没有stealable的Scanvenger时，会从Scanvenger pool中分配一个，当然分配完成后仍然需要初始化。</p></li></ul><p>核心伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">steal_scavengers</span><span class="hljs-params">(per_thread_ctx *t)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (per_thread_ctx *it : thread_list)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (CAS(it-&gt;stealable, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>))<br>        &#123;<br>            it-&gt;stolen = migrate_scavengers(t, it);<br>            it-&gt;stealable = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (!need_more_scavengers(t))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">get_scavengers</span><span class="hljs-params">(per_thread_ctx *t)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!steal_scavengers(t))<br>    &#123;<br>        fetch_scavengers_from_pool(t);<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">enter_blockable_call</span><span class="hljs-params">(per_thread_ctx *t)</span><br>&#123;<br>    t-&gt;stealable = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">exit_blockable_call</span><span class="hljs-params">(per_thread_ctx *t)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (!CAS(t-&gt;stealable, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>)) &#123;&#125;<br>    <span class="hljs-keyword">if</span> (t-&gt;stolen)<br>    &#123;<br>        get_scavengers(t);<br>        update_yield_targets(t-&gt;yield_contexts);<br>        t-&gt;stolen = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/msh-runtime.png" alt="msh-runtime.png"></p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><ul><li>在关闭SMT的场景，MSH可实现接近SMT 72%的scavengers吞吐量</li><li>如果给出更宽松的延迟 SLO，MSH 可以进一步权衡primary的延迟和scavengers吞吐量</li><li>相比SMT，当scavengers也处于停滞时，MSH 可以充分收集mem stall cycle，并且实现高达 2 倍的吞吐量。<br><img src="/img/msh-result.png" alt="msh-result"></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文章提供了一个很新颖的软件思路，来降低Memory Bound对程序性能带来的影响，实现了类似SMT的效果。文章的<a href="https://github.com/sosson97/msh">代码</a>已开源，看了下里面的scavengers是一段无意义的计算程序，和Primary业务程序并没有关联，因此仅仅是减小了memory stall的cycle，并没有实际提高Primary的性能。这个方案实际应用到优化具体业务性能仍然很困难，因为scavengers的代码需要是有意义的，能够在Primary发生memory bound时处理一些辅助任务，因此需要精心构造才行，这部分文章并没有体现。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://www.usenix.org/conference/osdi24/presentation/luo">Harvesting Memory-bound CPU Stall Cycles  in Software with MSH</a></p><p><a href="https://www.intel.com/content/www/us/en/docs/vtune-profiler/cookbook/2024-0/top-down-microarchitecture-analysis-method.html">Top-down Microarchitecture Analysis Method</a></p><p><a href="https://cloud.tencent.com/developer/article/2353832">Top-Down性能分析方法（原理篇）：揭秘代码运行瓶颈</a></p>]]></content>
    
    
    <categories>
      
      <category>Paper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kprobes 使用与原理介绍</title>
    <link href="/2023/11/08/kprobe/"/>
    <url>/2023/11/08/kprobe/</url>
    
    <content type="html"><![CDATA[<p>.</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Kprobes</code> (kprobe and kretprobe)是一种Linux的调试机制，用于监控系统内部事件。你可以使用 <code>Kprobes</code> 来解决性能瓶颈、记录特定事件、跟踪问题等。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="kprobes-接口"><a href="#kprobes-接口" class="headerlink" title="kprobes 接口"></a>kprobes 接口</h3><p>内核源码samples目录下 <a href="https://github.com/torvalds/linux/blob/master/samples/kprobes/kprobe_example.c">kprobes&#x2F;kprobe_example.c</a> 提供了 <code>Kprobes</code> 测试用例。代码非常简单，主要配置了 <code>struct kprobe</code> 如下几个字段：</p><ul><li>symbol_name</li><li>offset</li><li>pre_handler</li><li>post_handler</li></ul><p>最后调用 <code>register_kprobe()</code> 注册定义的kprobe。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> register<span class="hljs-constructor">_kprobe(<span class="hljs-params">struct</span> <span class="hljs-params">kprobe</span> <span class="hljs-operator">*</span><span class="hljs-params">p</span>)</span><br>void unregister<span class="hljs-constructor">_kprobe(<span class="hljs-params">struct</span> <span class="hljs-params">kprobe</span> <span class="hljs-operator">*</span><span class="hljs-params">p</span>)</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kprobe</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span> <span class="hljs-title">hlist</span>;</span><br><br>    <span class="hljs-comment">/* list of kprobes for multi-handler support */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><br><br>    <span class="hljs-comment">/*count the number of times this probe was temporarily disarmed */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nmissed;<br><br>    <span class="hljs-comment">/* location of the probe point */</span><br>    <span class="hljs-type">kprobe_opcode_t</span> *addr;<br><br>    <span class="hljs-comment">/* Allow user to indicate symbol name of the probe point */</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *symbol_name;<br><br>    <span class="hljs-comment">/* Offset into the symbol */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset;<br><br>    <span class="hljs-comment">/* Called before addr is executed. */</span><br>    <span class="hljs-type">kprobe_pre_handler_t</span> pre_handler;<br><br>    <span class="hljs-comment">/* Called after addr is executed, unless... */</span><br>    <span class="hljs-type">kprobe_post_handler_t</span> post_handler;<br><br>    <span class="hljs-comment">/* Saved opcode (which has been replaced with breakpoint) */</span><br>    <span class="hljs-type">kprobe_opcode_t</span> opcode;<br><br>    <span class="hljs-comment">/* copy of the original instruction */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">arch_specific_insn</span> <span class="hljs-title">ainsn</span>;</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Indicates various status flags.</span><br><span class="hljs-comment">     * Protected by kprobe_mutex after this kprobe is registered.</span><br><span class="hljs-comment">     */</span><br>    u32 flags;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="kprobe-trace"><a href="#kprobe-trace" class="headerlink" title="kprobe trace"></a>kprobe trace</h3><p>使用方法和基于tracepoint的events类似. 不同的是Kprobes可以probe几乎所有函数（除了标注__kprobes&#x2F;nokprobe_inline  和被标记为 NOKPROBE_SYMBOL的函数），且在系统运行时能够动态添加&#x2F;删除。使用方法详见内核文档 <a href="https://www.kernel.org/doc/html/latest/trace/kprobetrace.html">kprobetrace</a>。主要是使用如下接口:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/sys/</span>kernel<span class="hljs-regexp">/debug/</span>tracing/kprobe_events<br><span class="hljs-regexp">/sys/</span>kernel<span class="hljs-regexp">/debug/</span>tracing<span class="hljs-regexp">/events/</span>kprobes<span class="hljs-regexp">/&lt;EVENT&gt;/</span>enable<br><span class="hljs-regexp">/sys/</span>kernel<span class="hljs-regexp">/debug/</span>tracing/dynamic_events<br></code></pre></td></tr></table></figure><h3 id="bpftrace"><a href="#bpftrace" class="headerlink" title="bpftrace"></a>bpftrace</h3><p>bpftrace使用很简单，详见 <a href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md#1-kprobekretprobe-dynamic-tracing-kernel-level">bpftrace guide</a>。例如，使用 <code>bpftrace</code> 通过  <code>kretprobe</code> 获取 <code>ktime_get</code> 返回的时间：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">sudo bpftrace -e <span class="hljs-symbol">&#x27;kretprobe</span>:ktime_get &#123; printf(<span class="hljs-string">&quot;time: %lld\n&quot;</span>, retval);&#125;&#x27;<br></code></pre></td></tr></table></figure><h2 id="Kprobes在arm64上的实现"><a href="#Kprobes在arm64上的实现" class="headerlink" title="Kprobes在arm64上的实现"></a>Kprobes在arm64上的实现</h2><p>kprobe 和 kretprobe 原理相似，因此本文只分析kprobe流程。</p><h3 id="register-kprobe流程"><a href="#register-kprobe流程" class="headerlink" title="register_kprobe流程"></a>register_kprobe流程</h3><ul><li><code>arch_prepare_kprobe() → arch_prepare_ss_slot()</code>, 拷贝probe点的指令（接下来需要替换probe位置的指令），调用 <code>get_insn_slot()</code> 获取一个slot，按照如下顺序排放：<ul><li>拷贝的probe点的指令</li><li><code>brk 0x6</code></li></ul></li><li><code>arm_kprobe() → arch_arm_kprobe()</code>，probe位置的指令替换为 <code>brk 0x4</code></li></ul><blockquote><p> <code>BRK #&lt;imm&gt;</code>，立即数 <code>imm</code> 会保存会在 <code>ESR_ELx.ISS</code>。<br><img src="/img/ESR_EL1.png" alt="ESR, From ARM Architecture Reference Manual D17.2.37"></p></blockquote><h3 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h3><p>1、执行到probe点后，由于已经替换成了 <code>brk 0x4</code>，执行后陷入el1 debug异常。 <code>call_break_hook</code> 根据 <code>ESR.ISS</code>（0x4）调用 <code>kprobe_breakpoint_handler</code>，然后再根据probe点的 <code>addr</code> 在kprobes的哈希链表找到注册的kprobe结构体，再调用结构体里的 <code>pre_handler()</code> 就完成了。调用栈如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">handler_pre</span>+<span class="hljs-number">0</span>x24/<span class="hljs-number">0</span>x70<span class="hljs-meta"> [kprobe_example]</span><br><span class="hljs-attribute">kprobe_breakpoint_handler</span>+<span class="hljs-number">0</span>xc0/<span class="hljs-number">0</span>x174<br><span class="hljs-attribute">call_break_hook</span>+<span class="hljs-number">0</span>x88/<span class="hljs-number">0</span>xa4<br><span class="hljs-attribute">brk_handler</span>+<span class="hljs-number">0</span>x2c/<span class="hljs-number">0</span>x70<br><span class="hljs-attribute">do_debug_exception</span>+<span class="hljs-number">0</span>x6c/<span class="hljs-number">0</span>x110<br><span class="hljs-attribute">el1_dbg</span>+<span class="hljs-number">0</span>x68/<span class="hljs-number">0</span>x80<br><span class="hljs-attribute">el1h_64_sync_handler</span>+<span class="hljs-number">0</span>xb4/<span class="hljs-number">0</span>xd0<br><span class="hljs-attribute">el1h_64_sync</span>+<span class="hljs-number">0</span>x64/<span class="hljs-number">0</span>x68<br></code></pre></td></tr></table></figure><p>2、执行完 <code>pre_handler()</code> 后，跳转到之前保存的slot执行，第一条指令就是原来probe点的指令，接下来执行下一条指令 <code>brk 0x6</code> 后再次陷入异常。流程和上文相似，只不过 <code>ESR.ISS</code> 变成了 0x6， 因此 <code>call_break_hook</code> 调用 <code>kprobe_breakpoint_ss_handler</code>，最后执行完 <code>handler_post()</code> 并退出异常，继续正常的代码流程。调用栈如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">handler_post</span>+<span class="hljs-number">0</span>x24/<span class="hljs-number">0</span>x50<span class="hljs-meta"> [kprobe_example]</span><br><span class="hljs-attribute">post_kprobe_handler</span>+<span class="hljs-number">0</span>x60/<span class="hljs-number">0</span>xb0<br><span class="hljs-attribute">kprobe_breakpoint_ss_handler</span>+<span class="hljs-number">0</span>x94/<span class="hljs-number">0</span>xa0<br><span class="hljs-attribute">call_break_hook</span>+<span class="hljs-number">0</span>x88/<span class="hljs-number">0</span>xa4<br><span class="hljs-attribute">brk_handler</span>+<span class="hljs-number">0</span>x2c/<span class="hljs-number">0</span>x70<br><span class="hljs-attribute">do_debug_exception</span>+<span class="hljs-number">0</span>x6c/<span class="hljs-number">0</span>x110<br><span class="hljs-attribute">el1_dbg</span>+<span class="hljs-number">0</span>x68/<span class="hljs-number">0</span>x80<br><span class="hljs-attribute">el1h_64_sync_handler</span>+<span class="hljs-number">0</span>xb4/<span class="hljs-number">0</span>xd0<br><span class="hljs-attribute">el1h_64_sync</span>+<span class="hljs-number">0</span>x64/<span class="hljs-number">0</span>x68<br></code></pre></td></tr></table></figure><h2 id="Jump-Optimization"><a href="#Jump-Optimization" class="headerlink" title="Jump Optimization"></a>Jump Optimization</h2><p>ToDo</p><h3 id="Safety-Check"><a href="#Safety-Check" class="headerlink" title="Safety Check"></a>Safety Check</h3><h3 id="Preparing-Detour-Buffer"><a href="#Preparing-Detour-Buffer" class="headerlink" title="Preparing Detour Buffer"></a>Preparing Detour Buffer</h3><h3 id="Pre-optimization"><a href="#Pre-optimization" class="headerlink" title="Pre-optimization"></a>Pre-optimization</h3><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://lwn.net/Articles/132196/">An introduction to KProbes</a></li><li><a href="https://blog.arstercz.com/introduction_to_linux_dynamic_tracing/">Linux 系统动态追踪技术介绍</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>kernel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kernel</tag>
      
      <tag>trace</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux进程管理：CFS组调度</title>
    <link href="/2023/05/01/Linux-group-scheduling/"/>
    <url>/2023/05/01/Linux-group-scheduling/</url>
    
    <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>如果一个用户创建了大量进程，由于CFS的机制，这些进程会和其他用户的进程按照优先级对应比例瓜分CPU时间，最总导致这个用户占用过多的CPU时间。引入组调度后，就可以按照任务组的粒度来平分CPU时间，防止以上的问题出现。struct task_group用于描述一个任务组，裁剪后的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_group</span> &#123;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span><br>        <span class="hljs-comment">/* schedulable entities of this group on each CPU */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_entity</span>     **<span class="hljs-title">se</span>;</span><br>        <span class="hljs-comment">/* runqueue &quot;owned&quot; by this group on each CPU */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfs_rq</span>           **<span class="hljs-title">cfs_rq</span>;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>           shares;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>        <span class="hljs-title">list</span>;</span><br><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_group</span>       *<span class="hljs-title">parent</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>        <span class="hljs-title">siblings</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>        <span class="hljs-title">children</span>;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SCHED_AUTOGROUP</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">autogroup</span>        *<span class="hljs-title">autogroup</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;                                                                     <br></code></pre></td></tr></table></figure><ul><li><p><code>se[i]</code> 表示这个<code>task_group</code>在第 i 个 CPU 上的 调度实体, 该<code>se</code>代表的也是一个任务组。</p></li><li><p><code>cfs_rq[i]</code>指向这个任务组在第i个CPU上的rq，组织这个任务组在该CPU上的任务，也等于<code>se[i].my_rq</code></p></li></ul><p><code>sched_entity</code>结构体如下，通过<code>my_q</code>可以判断一个调度实体是否是任务组，如果该为 NULL, 则表示一个任务，否则就是一个任务组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_entity</span> &#123;</span><br>        <span class="hljs-comment">/* For load-balancing: */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">load_weight</span>              <span class="hljs-title">load</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span>                  <span class="hljs-title">run_node</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>                <span class="hljs-title">group_node</span>;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>                    on_rq;<br><br>        u64                             exec_start;<br>        u64                             sum_exec_runtime;<br>        u64                             vruntime;<br>        u64                             prev_sum_exec_runtime;<br><br>        u64                             nr_migrations;<br>        <br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_statistics</span>         <span class="hljs-title">statistics</span>;</span><br>        <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span><br>        <span class="hljs-type">int</span>                             depth;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_entity</span>             *<span class="hljs-title">parent</span>;</span><br>        <span class="hljs-comment">/* rq on which this entity is (to be) queued: */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfs_rq</span>                   *<span class="hljs-title">cfs_rq</span>;</span><br>        <span class="hljs-comment">/* rq &quot;owned&quot; by this entity/group: */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfs_rq</span>                   *<span class="hljs-title">my_q</span>;</span><br>        <span class="hljs-comment">/* cached value of my_q-&gt;h_nr_running */</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>                   runnable_weight;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/wp_editor_md_1b6edc49fa6d706aade6d2e82c4f1344.jpg" alt="来自https://www.laumy.tech/736.html#lwptoc"></p><p>内核有一个全局链表<code>task_groups</code>，新创建的<code>task_group</code>会添加到这个链表中；全局根节点struct task_group root_task_group以及</p><h2 id="创建任务组-x2F-添加任务"><a href="#创建任务组-x2F-添加任务" class="headerlink" title="创建任务组&#x2F;添加任务"></a>创建任务组&#x2F;添加任务</h2><p>cpuset相关函数handler如下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">struct cgroup_subsys cpuset_cgrp_subsys = &#123;<br>        <span class="hljs-string">.css_alloc</span>      = cpuset_css_alloc,<br>        <span class="hljs-string">.css_online</span>     = cpuset_css_online,<br>        <span class="hljs-string">.css_offline</span>    = cpuset_css_offline,<br>        <span class="hljs-string">.css_free</span>       = cpuset_css_free,<br>        <span class="hljs-string">.can_attach</span>     = cpuset_can_attach,<br>        <span class="hljs-string">.cancel_attach</span>  = cpuset_cancel_attach,<br>        <span class="hljs-string">.attach</span>         = cpuset_attach,<br>        <span class="hljs-string">.post_attach</span>    = cpuset_post_attach,<br>        <span class="hljs-string">.bind</span>           = cpuset_bind,<br>        <span class="hljs-string">.fork</span>           = cpuset_fork,<br>        <span class="hljs-string">.legacy_cftypes</span> = legacy_files,<br>        <span class="hljs-string">.dfl_cftypes</span>    = dfl_files,<br>        <span class="hljs-string">.early_init</span>     = <span class="hljs-literal">true</span>,<br>        <span class="hljs-string">.threaded</span>       = <span class="hljs-literal">true</span>,<br>&#125;;              <br></code></pre></td></tr></table></figure><p>通过cgroup的接口可以很方便地创建一个调度组，对应内核代码流程为：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">cgorup_mkdir</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">cgroup_apply_control_enable</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">cpuset_css_alloc</span>-&gt;</span>cpuset_css_online<br></code></pre></td></tr></table></figure><p>往一个任务组添加任务流程如下：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">cgroup_file_write</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">cgroup_attach_task</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">cgroup_migrate</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">cgroup_migrate_execute</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">cpu_cgroup_attach</span>-&gt;</span>sched_move_task<br></code></pre></td></tr></table></figure><h2 id="调度逻辑"><a href="#调度逻辑" class="headerlink" title="调度逻辑"></a>调度逻辑</h2><p>组调度并没有改变太多的CFS调度逻辑，下面主要分析下选任务和时间分配相关变更：</p><ul><li>任务挑选</li></ul><p>摘取核心逻辑如下，如果<code>se</code>的<code>cfs_rq</code>是NULL，代表这个<code>se</code>是一个任务，因此不进入循环；对于任务组，会一直循环<code>cfs_rq</code>里的<code>se</code>，直到找到一个<code>se</code>是一个任务。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> task_struct *<span class="hljs-title function_">pick_next_task_fair</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rq *rq, <span class="hljs-keyword">struct</span> task_struct *prev,</span><br><span class="hljs-params">                                <span class="hljs-keyword">struct</span> rq_flags *rf)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfs_rq</span> *<span class="hljs-title">cfs_rq</span> =</span> &amp;rq-&gt;cfs;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_entity</span> *<span class="hljs-title">se</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">p</span>;</span><br><br>    <span class="hljs-keyword">do</span> &#123;<br>        se = pick_next_entity(cfs_rq, <span class="hljs-literal">NULL</span>);<br>cfs_rq = group_cfs_rq(se);<br>    &#125; <span class="hljs-keyword">while</span> (cfs_rq);<br>    p = task_of(se);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间分配</li></ul><p>如果se代表的是任务组，那么该<code>se</code>在当前<code>cfsrq</code>中根据任务组的时间份额进行二次分配。相关函数是 <code>sched_slice</code>，采用自下而上的方式遍历整个<code>cfs_rq</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> for_each_sched_entity(se) \</span><br><span class="hljs-meta">                for (; se; se = se-&gt;parent)</span><br><br><span class="hljs-type">static</span> u64 <span class="hljs-title function_">sched_slice</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cfs_rq *cfs_rq, <span class="hljs-keyword">struct</span> sched_entity *se)</span><br>&#123;<br>        u64 slice = __sched_period(cfs_rq-&gt;nr_running + !se-&gt;on_rq);<br><br>        for_each_sched_entity(se) &#123;<br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">load_weight</span> *<span class="hljs-title">load</span>;</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">load_weight</span> <span class="hljs-title">lw</span>;</span><br>       <br>                cfs_rq = cfs_rq_of(se);<br>                load = &amp;cfs_rq-&gt;load;<br><br>                <span class="hljs-keyword">if</span> (unlikely(!se-&gt;on_rq)) &#123;<br>                        lw = cfs_rq-&gt;load;<br>       <br>                        update_load_add(&amp;lw, se-&gt;load.weight);<br>                        load = &amp;lw;<br>                &#125;<br>                slice = __calc_delta(slice, se-&gt;load.weight, load);<br>        &#125;<br>        <span class="hljs-keyword">return</span> slice;<br>&#125;<br></code></pre></td></tr></table></figure><p>如下示意图很清楚地解释了计算过程，最终SE2的时间为<code>slice * r2 * r1 * r0</code>，也很容易理解，因为<code>r0 * r1 * r2</code>就是SE2在整个cfs_rq里的权重占比。</p><p><img src="/img/group-scheduling.png" alt="来自https://s3.shizhz.me/linux-sched/cfs-sched/group-timeshare"></p><center></center><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://git.kernel.org/">Linux Source V5.10</a></li><li><a href="https://bluepuni.com/archives/cfs-basic/">Linux 内核的 CFS 任务调度</a></li><li><a href="https://s3.shizhz.me/linux-sched/cfs-sched/group">Linux核心概念详解</a></li><li><a href="https://www.cnblogs.com/LoyenWang/p/12459000.html">Linux进程调度-组调度及带宽控制</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>kernel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux kernel会议频道归档</title>
    <link href="/2023/01/29/linux-channel/"/>
    <url>/2023/01/29/linux-channel/</url>
    
    <content type="html"><![CDATA[<p>归档Linux相关会议 youtube 频道，优秀的程序员应该具有国际视野 :-)</p><p><a href="https://www.youtube.com/c/LinuxPlumbersConference/videos">Linux Plumbers Conference</a></p><blockquote><p>Linux Plumbers Conference 2022 features tracts on system boot, kernel memory management, kernel testing, the Rust programming language, CPU isolation, eBPF, confidential computing, real-time and scheduling, toolchains, power management, Compute Express Link (CXL), and other exciting topics.</p></blockquote><p><a href="https://www.youtube.com/c/LinuxfoundationOrg">The Linux Foundation</a></p><blockquote><p>The Linux Foundation provides a neutral forum for collaboration and education by hosting Collaborative Projects, Linux conferences including LinuxCon, and generating original research and content that advances the understanding of Linux and collaborative software development.</p></blockquote><p><a href="https://www.youtube.com/c/Hupstream/videos">Kernel Recipes</a></p><blockquote><p>Informal conference about the Linux kernel in Paris – next edition, 1-3 june 2022</p></blockquote><p><a href="https://www.youtube.com/channel/UCt50fEvgrEuN9fvya8ujVzA/videos">Performance Summit</a></p><blockquote><p>Performance Summit events serve as a place for software performance enthusiasts and practitioners to meet and discuss challenges, research and possible solutions around delivering delightful and efficient software solutions.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>kernel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(ongoing) Linux死锁检测-Lockdep分析</title>
    <link href="/2022/09/07/lockdep-design/"/>
    <url>/2022/09/07/lockdep-design/</url>
    
    <content type="html"><![CDATA[<h2 id="lock-class"><a href="#lock-class" class="headerlink" title="lock class"></a>lock class</h2><p>lockdep 跟踪基本单元并不是每个锁的实例，而是锁类（lock class），在 <a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">Runtime locking correctness validator</a> 这篇文章中 lockdep 作者 Ingo Molnar 解释了什么是锁类：</p><blockquote><p>A class of locks is a group of locks that are logically the same with respect to locking rules, even if the locks may have multiple (possibly tens of thousands of) instantiations. For example a lock in the inode struct is one class, while each inode has its own instantiation of that lock class.</p></blockquote><p>毫无疑问这种说法是准确的（毕竟是 Ingo 大佬），但是对于我这种小白来说未免过于抽象 :)。查阅代码后才理解了锁类的准确含义，以 spinlock 为例，在锁的初始化时定义了一个静态变量 __key，因此如果多个锁实例使用的 __key是同一个，那么它们就是同一个锁类，并采用哈希表来存储。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-keyword">define</span> raw_spin_lock_init(lock)                   \</span><br><span class="hljs-meta">do &#123;                                    \</span><br><span class="hljs-meta">    static struct lock_class_key __key;             \</span><br><span class="hljs-meta">                                    \</span><br><span class="hljs-meta">    __raw_spin_lock_init((lock), #lock, &amp;__key, LD_WAIT_SPIN);  \</span><br><span class="hljs-meta">&#125; while (0)</span><br></code></pre></td></tr></table></figure><p>以如下代码片段为例，如果打开lockdep功能后：</p><ul><li>xxx_function1()执行时 lockdep 会打印警告：[ INFO: possible recursive locking detected ] ，当然，这显然是一个误报，并不是真的会死锁。由于__key是静态定义的，因此只要锁初始化时的代码位置相同(正如 xxx_function1 中的st1.lock 和 st2.lock)，它们就是一个锁类。</li><li>xxx_function2() 则不会打印任何警告，因为 st1.lock 和 st2.lock 对应不同的 __key。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">st</span> &#123;</span><br><span class="hljs-type">spinlock_t</span>lock;<br>    <span class="hljs-type">int</span> some_var;<br>&#125;<br><br>xxx_function1() &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">st</span> <span class="hljs-title">st1</span>, <span class="hljs-title">st2</span>;</span><br><br>    xxx_init(&amp;st1);<br>    xxx_init(&amp;st2);<br><br>    recursive_locking(&amp;st1.lock, &amp;st2.lock);<br>&#125;<br><br>xxx_function2() &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">st</span> <span class="hljs-title">st1</span>, <span class="hljs-title">st2</span>;</span><br><br>spin_lock_init(&amp;st1.lock);<br>spin_lock_init(&amp;st2.lock);<br><br>    recursive_locking(&amp;st1.lock, &amp;st2.lock);<br><br>&#125;<br><br>xxx_init(<span class="hljs-keyword">struct</span> st *a)<br>&#123;<br>spin_lock_init(&amp;a-&gt;lock);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">recursive_locking</span><span class="hljs-params">(<span class="hljs-type">spinlock_t</span> *a1, <span class="hljs-type">spinlock_t</span> *a2)</span><br>&#123;<br>    spin_lock(a1);<br>    spin_lock(a2);<br><br>    spin_unlock(a2);<br>    spin_unlock(a1);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="lock-usage-state"><a href="#lock-usage-state" class="headerlink" title="lock usage state"></a>lock usage state</h2><p>待完善</p><h2 id="lockdep-检查规则"><a href="#lockdep-检查规则" class="headerlink" title="lockdep 检查规则"></a>lockdep 检查规则</h2><p>待完善</p><h2 id="lockdep-代码分析"><a href="#lockdep-代码分析" class="headerlink" title="lockdep 代码分析"></a>lockdep 代码分析</h2><p>待完善</p>]]></content>
    
    
    <categories>
      
      <category>kernel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kernel</tag>
      
      <tag>lock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>获取Linux内核邮件列表补丁以及邮件</title>
    <link href="/2022/08/15/b4-workflow-tool/"/>
    <url>/2022/08/15/b4-workflow-tool/</url>
    
    <content type="html"><![CDATA[<p><a href="http://lore.kernel.org/">lore.kernel.org</a> 网站归档了 linux 内核社区的邮件，在上面可以看到社区最新的讨论以及各个模块的补丁，为了便于获取上面的补丁和邮件，社区开发了 b4 工具。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>以下两种方法都可以获取 b4 工具：</p><ul><li>通过 pip 安装<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo pip install b4<br></code></pre></td></tr></table></figure></li><li>直接从源码启动<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://git.kernel.org/pub/scm/utils/b4/b4.git<br></code></pre></td></tr></table></figure></li></ul><h2 id="获取补丁"><a href="#获取补丁" class="headerlink" title="获取补丁"></a>获取补丁</h2><p>在 lore.kernel.org 找到我们需要的补丁集，比如想要获取这组 rcu 补丁集：<br><a href="https://lore.kernel.org/all/20220831180759.GA2693289@paulmck-ThinkPad-P17-Gen-1/">https://lore.kernel.org/all/20220831180759.GA2693289@paulmck-ThinkPad-P17-Gen-1/</a><br>把链接中的message id (url 中间部分)放在 am 选项后即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./b4.sh am 20220831180759.GA2693289@paulmck-ThinkPad-P17-Gen-1<br></code></pre></td></tr></table></figure><p>同一个补丁集中不同补丁的 message id 不同，但任意一个 message id 都可以让 b4 工具获取到完整的补丁集。成功后能够获取到补丁封面 .cover 和 mbox 格式（ready to git-am）的补丁内容。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console">20220831_paulmck_miscellaneous_fixes_for_v6_1.cover<br>20220831_paulmck_miscellaneous_fixes_for_v6_1.mbx<br></code></pre></td></tr></table></figure><p>进入linux 源码仓，git am 20220831_paulmck_miscellaneous_fixes_for_v6_1.mbx 即可合入补丁。</p><h2 id="获取-mbox"><a href="#获取-mbox" class="headerlink" title="获取 mbox"></a>获取 mbox</h2><p>另一个实用的场景是：如果没有没有订阅内核邮件列表或者错过了某些邮件，又想要参与这个补丁的社区讨论。我们可以通过 b4 工具抓去对应的 mbox 文件后导入到邮箱软件中，之后便可以正常参与讨论交流了。<br>方法和上面一致，am 替换成 mbox 即可。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">./b4.<span class="hljs-keyword">sh</span> mbox 20220831180759.GA2693289@paulmck-ThinkPad-P17-<span class="hljs-keyword">Gen</span>-1<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>kernel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kernel</tag>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用 debootstrap 构建 Debian/Ubuntu 文件系统</title>
    <link href="/2022/07/24/qemu-debian/"/>
    <url>/2022/07/24/qemu-debian/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>构建根文件系统常见的方法有 busybox, buildroot, yocto 等， 对应的资料网络上都很丰富，缺点是功能过于简单或者步骤过于复杂。采用 Ubuntu&#x2F;Debian 文件系统是个不错的选择，通过 apt 能够复用 ubuntu&#x2F;debian 软件生态，自动解决软件依赖。debootstrap 是一个用来构建 Debian base 系统(根文件系统)的工具，通过 debootstrap 可以很轻松地构建出一个 Debian&#x2F;Ubuntu 文件系统。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>安装 qemu-system-aarch64</li><li>安装 qemu-user-static</li><li>安装 debootstrap</li><li>正确配置并编译好的内核镜像</li></ul><h2 id="文件系统构建"><a href="#文件系统构建" class="headerlink" title="文件系统构建"></a>文件系统构建</h2><p>首先创建一个 ext4 文件系统并挂载，512 MiB 大小就足够了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> tmp-rootfs<br>sudo <span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=rootfs-debian.ext4 bs=1MiB count=512<br>sudo mkfs.ext4 rootfs-debian.ext4<br>sudo mount rootfs-debian.ext4 tmp-rootfs<br></code></pre></td></tr></table></figure><p>debootstrap 简要用法如下，详细用法可查看 <code>man debootstrap</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">debootstrap [OPTION]... &lt;suite&gt; &lt;target&gt; &lt;mirror&gt;<br>debootstrap [OPTION] --second-stage<br></code></pre></td></tr></table></figure><ul><li>suite 是指版本代号，如 <a href="https://wiki.debian.org/DebianReleases#Production_Releases">debian</a> 的 buster 或者 <a href="https://wiki.ubuntu.com/Releases">ubuntu</a> 的 jammy，填第一个单词的小写就行了</li><li>target 是指目标架构，如 arm64</li><li>mirror 是指构建 Debian&#x2F;Ubuntu 的镜像源</li></ul><p>这里我们用华为的镜像源构建 Debian buster 版本 arm64 系统：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console">sudo debootstrap --verbose --arch=arm64 buster tmp-rootfs http://mirrors.huaweicloud.com/debian<br></code></pre></td></tr></table></figure><p>同样，如果想构建 Ubuntu 系统则修改 suite 和 mirror 即可：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console">sudo debootstrap --verbose --arch=arm64 jammy tmp-rootfs http://mirrors.huaweicloud.com/ubuntu-ports<br></code></pre></td></tr></table></figure><p>执行结束后就会在我们创建的 tmp-rootfs 目录生成所需要的 Debian 系统。</p><h2 id="文件系统配置"><a href="#文件系统配置" class="headerlink" title="文件系统配置"></a>文件系统配置</h2><p>文件系统构建完成后，我们还需要配置网络、安装软件，配置用户等。</p><p>首先拷贝之前安装的 qemu-static 工具到我们的文件系统，因为我们这里的 host 是 x86 架构，通过 host 配置系统时需要运行文件系统内的 arm64 架构的程序，需要 qemu-aarch64-static 对进行用户模式模拟。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console">sudo cp /usr/bin/qemu-aarch64-static tmp-rootfs/usr/bin<br></code></pre></td></tr></table></figure><p>之后 chroot 到文件系统：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console">sudo chroot tmp-rootfs<br></code></pre></td></tr></table></figure><p>按照个人需求创建用户和修改密码：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console">passwd<br>...<br></code></pre></td></tr></table></figure><p>同样按照个人需求安装软件：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console">apt install net-tools vim wget curl<br></code></pre></td></tr></table></figure><p>最后还需要配置网络，QMEU 网络配置详情查看 <a href="https://wiki.qemu.org/Documentation/Networking">QEMU Networking</a>，这里配置最简单的用户模式网卡。<br><img src="/img/Slirp_concept.png" alt="QEMU User Networking"></p><p>同时具体配置方法和系统也相关，以 Debian buster 为例，网络是由 <code>/etc/network/interfaces</code> 文件配置的，将以下内容写入该文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">auto lo<br>iface lo inet loopback<br><br>auto eth0<br>iface eth0 inet dhcp<br>  wait-delay 15<br>  hostname $(hostname)<br></code></pre></td></tr></table></figure><p>对于 QEMU 用户模式网卡，需要配置 DNS 服务器为 10.0.2.3，将以下内容写入 <code>/etc/resolv.conf</code>。注意：此时 DNS 服务器地址和 host 不一样了，因此在 host 上 chroot 后安装软件会失败。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;nameserver 10.0.2.3&quot;</span> &gt; /etc/resolv.conf<br></code></pre></td></tr></table></figure><p>最后 umount 文件系统就大功告成了 :)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo umount tmp-rootfs<br></code></pre></td></tr></table></figure><h2 id="运行-QEMU"><a href="#运行-QEMU" class="headerlink" title="运行 QEMU"></a>运行 QEMU</h2><p>通过如下命令启动 QEMU 环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">qemu-system-aarch64 -M virt -cpu cortex-a53 -nographic -smp 8 -kernel Image \<br>    -append <span class="hljs-string">&quot;rootwait root=/dev/vda rw console=ttyAMA0&quot;</span> \<br>    -netdev user,<span class="hljs-built_in">id</span>=eth0,hostfwd=tcp::17777-:22 -device virtio-net-device,netdev=eth0 \<br>    -drive file=rootfs-debian.ext4,<span class="hljs-keyword">if</span>=none,format=raw,<span class="hljs-built_in">id</span>=hd0 -device virtio-blk-device,drive=hd0 <br></code></pre></td></tr></table></figure><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="Ubuntu-jammy-网络异常"><a href="#Ubuntu-jammy-网络异常" class="headerlink" title="Ubuntu jammy 网络异常"></a>Ubuntu jammy 网络异常</h3><p>使用 Ubuntu jammy 发现通过 <code>netplan</code> 配置网络不成功，每次启动网卡没有 up。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">network:</span><br>  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">renderer:</span> <span class="hljs-string">NetworkManager</span><br>  <span class="hljs-attr">ethernets:</span><br>    <span class="hljs-attr">eth0:</span><br>      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>怀疑和 <code>NetworkManager.service</code> 没有起来相关，同时系统 <code>systemd-resolved.service</code> 会自动生成错误的 DNS 地址（和 host 的相同），目前解决办法只能手动配置 DNS ，网卡和路由。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">echo</span> <span class="hljs-string">&quot;nameserver 10.0.2.3&quot;</span> &gt; /etc/resolv.conf<br>ifconfig eth0 <span class="hljs-number">10.0.2.15</span>  netmask <span class="hljs-number">255.255.255.0</span><br>route add default gw <span class="hljs-number">10.0.2.2</span><br></code></pre></td></tr></table></figure><p>更新：安装 nmcli 后问题解决（Ubuntu 太坑了，这种核心软件没有提前安装好），使用方法可以看看这篇文章 <a href="https://www.liquidweb.com/kb/how-to-install-and-configure-nmcli/">How to Install and Configure Nmcli</a></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">apt <span class="hljs-keyword">install</span> network-manager<br></code></pre></td></tr></table></figure><p>然后用 <code>netplan</code> 配置网卡</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">vim</span> /etc/netplan/<span class="hljs-number">01</span>-network-manager-<span class="hljs-literal">all</span>.yaml<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">network:</span><br>  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">renderer:</span> <span class="hljs-string">NetworkManager</span><br>  <span class="hljs-attr">ethernets:</span><br>    <span class="hljs-attr">eth0:</span><br>      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">nameservers:</span><br>        <span class="hljs-attr">addresses:</span> [<span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.3</span>]<br><br></code></pre></td></tr></table></figure><h2 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h2><ul><li>完善 netplan 方式配置网卡</li><li>完善 nmcli 使用方法</li><li>写一篇文章整理 QEMU 网卡配置，包括tap&#x2F;tun 模式网卡配置</li><li>QEMU 使用其他模式网卡时 debian&#x2F;ubuntu 网络怎么配置</li><li>Linux kernel tap&#x2F;tun 原理分析</li><li>将构建过程整理成脚本，提交到 <a href="https://github.com/yuliao0214/qemu-vm">qemu-vm</a> 仓库</li></ul>]]></content>
    
    
    <categories>
      
      <category>QEMU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VIM使用总结</title>
    <link href="/2022/06/03/vim/"/>
    <url>/2022/06/03/vim/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>总结个人常用的操作，能够覆盖绝大多数场景，除了怎么退出vim(<a href="https://www.runoob.com/linux/linux-vim.html">菜鸟教程</a>)。</p><h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><ul><li><code>Ctrl + d</code> &amp; <code>ctrl + u</code> 向下&#x2F;向上翻半页</li><li><code>h</code> <code>j</code> <code>k</code> <code>l</code> &#x3D; <code>←</code> <code>↓</code> <code>↑</code> <code>→</code></li><li><code>gg</code> &amp; <code>G</code> 跳到第一行&#x2F;最后一行</li><li><code>H</code>, <code>M</code>, <code>L</code>, 跳到当前屏幕的第一行(High)，中间(Middle)，最后一行(Low)</li><li><code>b</code>, <code>w</code> 以一个word为单位向前&#x2F;先后移动光标</li></ul><h2 id="光标选中"><a href="#光标选中" class="headerlink" title="光标选中"></a>光标选中</h2><p>按下按键后松开就进入了可视模式，然后用上面提到的光标移动按键选中需要的文本。可视模式分为一下三种，看图就明白了：</p><ul><li><p>字符模式：v<br><img src="/img/visual.png" alt="visual"></p></li><li><p>行模式：V<br><img src="/img/visual-line.png" alt="visual"></p></li><li><p>块模式：ctrl+v<br><img src="/img/visual-block.png" alt="visual"></p></li></ul><blockquote><p>Tip: <code>viw</code> 选中一个单词</p></blockquote><h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><p>结合前面提到的光标选中和光标移动后就可以复制、删除和粘贴文本了</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul><li><code>i</code> &amp; <code>a</code> 当前光标输入和当前光标下一个位置输入</li><li><code>o</code> &amp; <code>O</code> 在下一行&#x2F;上一行处输入</li><li><code>r</code> 替换光标字符</li><li><code>I</code> 配合 visual-block 模式可以实现多行编辑</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li><code>x</code> 删除字符</li><li><code>dd</code> 删除行</li></ul><blockquote><p>Tip: <code>diw</code> 删除一个单词</p></blockquote><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul><li><code>y</code> 复制已选中的文本</li><li><code>yy</code> 复制光标所在行</li></ul><h3 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h3><p><code>p</code> 粘贴到光标后<br><code>P</code> 粘贴到光标后</p><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><ul><li><code>u</code> 撤销上一次操作</li><li><code>Ctrl + r</code> 和上面相反的效果</li></ul><h2 id="多窗口编辑"><a href="#多窗口编辑" class="headerlink" title="多窗口编辑"></a>多窗口编辑</h2><ul><li>vim -O file1 file2</li><li><code>Crtl + w + v</code>复制当前窗口（左右分割）</li><li><code>Crtl + w + c</code>关闭当前窗口</li><li><code>Ctrl + w + w</code>在多窗口间切换</li><li>:e file 更改当前文件</li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul><li>ctags &amp; cscope 跳转</li><li>NERDTreeToggle 显示目录</li><li>taglist 显示tag</li><li>gruvbox 很好看的主题，有dark&#x2F;light两种颜色</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>使用管道（Pipe）<br>cmd | vim -</p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V timer 在 Linux 中的实现</title>
    <link href="/2022/05/01/riscv-linux-timer/"/>
    <url>/2022/05/01/riscv-linux-timer/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Author:  Yu Liao <a href="mailto:&#121;&#x75;&#x6c;&#105;&#97;&#x6f;&#x30;&#x32;&#49;&#x34;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;">&#121;&#x75;&#x6c;&#105;&#97;&#x6f;&#x30;&#x32;&#49;&#x34;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;</a><br>Revisor: lzufalcon <a href="mailto:&#102;&#x61;&#x6c;&#x63;&#111;&#110;&#x40;&#x74;&#x69;&#110;&#121;&#108;&#x61;&#x62;&#46;&#111;&#114;&#x67;">&#102;&#x61;&#x6c;&#x63;&#111;&#110;&#x40;&#x74;&#x69;&#110;&#121;&#108;&#x61;&#x62;&#46;&#111;&#114;&#x67;</a><br>Project: <a href="https://gitee.com/tinylab/riscv-linux">RISC-V Linux 内核剖析</a></p></blockquote><h2 id="RISC-V-timer-相关寄存器"><a href="#RISC-V-timer-相关寄存器" class="headerlink" title="RISC-V timer 相关寄存器"></a>RISC-V timer 相关寄存器</h2><h3 id="mtime-amp-mtimecmp-寄存器"><a href="#mtime-amp-mtimecmp-寄存器" class="headerlink" title="mtime &amp; mtimecmp 寄存器"></a>mtime &amp; mtimecmp 寄存器</h3><p>按照 RISC-V 定义，系统需要提供两个 64 位的 M 模式寄存器 <code>mtime</code> 和 <code>mtimecmp</code>，并通过 MMIO 方式映射到地址空间。</p><p><code>mtime</code> 需要以固定的频率递增，并在发生溢出时回绕。当 <code>mtime</code> 大于或等于 <code>mtimecmp</code> 时，由核内中断控制器 (CLINT, Core-Local Interrupt Controller) 产生 timer 中断。中断的使能由 <code>mie</code> 寄存器中的 <code>MTIE</code> 和 <code>STIE</code> 位控制，<code>mip</code> 中的 <code>MPIE</code> 和 <code>SPIE</code> 则指示了 timer 中断是否处于 pending。在 RV32 中读取 <code>mtimecmp</code> 结果为低 32 位， <code>mtimecmp</code> 的高 32 位需要读取 <code>mtimecmph</code> 得到。</p><p>在 <a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">RISC-V 特权 ISA 规范</a> 的 3.2.1 Machine Timer Registers (mtime and mtimecmp) 中详细介绍了这部分。</p><h3 id="time-CSR"><a href="#time-CSR" class="headerlink" title="time CSR"></a>time CSR</h3><p>RISC-V 还定义了一个 64 位非特权 CSR 寄存器 <code>time</code>，<code>time</code> 计数器是前面提到的 <code>mtime</code> 的只读映射。同样，在 RV32 中 <code>timeh</code> CSR 是 <code>mtime</code> 高 32 位的只读映射，对于 M 模式和 S 模式它们都是可读写的。</p><p>在 <a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">RISC-V 特权 ISA 规范</a> 的 2.2 CSR Listing 和 3.1.11 Machine Counter-Enable Register (mcounteren) 可以找到这块的规范。</p><h3 id="htimedelta-amp-htimedeltah-寄存器"><a href="#htimedelta-amp-htimedeltah-寄存器" class="headerlink" title="htimedelta &amp; htimedeltah 寄存器"></a>htimedelta &amp; htimedeltah 寄存器</h3><p>在增加虚拟化扩展以后，特权模式会发生一定变化，如下图（来源于参考文档 5）所示：</p><p><img src="/img/riscv-privilege-mode.png" alt="RISC-V 虚拟化特权模式"></p><p>相应地，timer 支持也进行了如下扩展：</p><p><code>htimedelta</code> 和 <code>htimedeltah</code> 是 Hypervisor 扩展里的 CSR，在 VS&#x2F;VU 模式下读取 <code>time</code> 结果是真正的 host 中的 <code>time</code> 加上 <code>htimedelta</code>。同样的，对于 RV32 <code>htimedelta</code> 保存了低 32 位，高 32 位保存在 <code>htimedeltah</code>。</p><p>在 <a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">RISC-V 特权 ISA 规范</a> 的 8.2.7  Hypervisor Time Delta Registers (htimedelta, htimedeltah) 中详细介绍了这部分。</p><h3 id="Sstc-扩展"><a href="#Sstc-扩展" class="headerlink" title="Sstc 扩展"></a>Sstc 扩展</h3><p>由于 <code>mtimecmp</code> 只能在 M 模式下访问，对于 S&#x2F;HS 模式下的内核和 VU&#x2F;VS 模式下的虚拟机需要通过 SBI 才能访问，会造成较大的中断延迟和性能开销。为了解决这一问题，RISC-V 新增了 Sstc 拓展支持（已批准但尚未最终集成到规范中）。</p><p>Sstc 扩展为 HS 模式和 VS 模式分别新增了 <code>stimecmp</code> 和 <code>vstimecmp</code> 寄存器，当 $time &gt;&#x3D; stimecmp$  (HS)或 $time+htimedelta &gt;&#x3D; vstimecmp$  (VS)时会产生 timer 中断，不再需要通过 SBI 陷入其他模式。</p><p>详见 <a href="https://github.com/riscv/riscv-time-compare/releases/download/v0.5.4/Sstc.pdf">RISC-V “stimecmp &#x2F; vstimecmp” 扩展</a> 。</p><h2 id="Linux-timer-实现"><a href="#Linux-timer-实现" class="headerlink" title="Linux timer 实现"></a>Linux timer 实现</h2><p>Linux 将底层时钟硬件抽象为两类设备：clockevent 和 clocksource，前者用来在未来指定的时间产生中断，通常用作定时器；后者则用于维护自系统启动以来所经过的时间。</p><p>当前 Linux 为 RISC-V 根据内核运行模式实现了两套驱动，代码路径为 drivers&#x2F;clocksource&#x2F;timer-riscv.c 和 drivers&#x2F;clocksource&#x2F;timer-clint.c。</p><p>本文代码基于最新的 Linux v5.18-rc4 和 OpenSBI v1.0，截止目前 Linux 对 Sstc 扩展的支持还没有合入主线内核，社区已有相关补丁：<a href="https://lkml.org/lkml/2022/3/4/1175">Add Sstc extension support</a>。</p><p><code>mtime</code> 频率由设备树 CPU 节点中的 timebase-frequency 定义，不同平台都各不相同，如 Kendryte K210 的频率是 7.8 MHz，平头哥 C910 的频率是 3 MHz，SiFive Unmatched A00 频率为 1 MHz。</p><h3 id="NoMMU-timer-clint-c"><a href="#NoMMU-timer-clint-c" class="headerlink" title="NoMMU timer-clint.c"></a>NoMMU timer-clint.c</h3><p>timer-clint.c 驱动适用于 NoMMU 系统，内核运行在 M 模式下，通过 CONFIG_CLINT_TIMER 使能该驱动。RV64 下 clocksource 是通过直接读取 <code>mtime</code> 寄存器实现的，RV32 系统需要分两次读取，并需要考虑产生进位的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_64BIT</span><br><span class="hljs-type">static</span> u64 notrace <span class="hljs-title function_">clint_get_cycles64</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> clint_get_cycles();<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* CONFIG_64BIT */</span></span><br><span class="hljs-type">static</span> u64 notrace <span class="hljs-title function_">clint_get_cycles64</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    u32 hi, lo;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        hi = clint_get_cycles_hi();<br>        lo = clint_get_cycles();<br>    &#125; <span class="hljs-keyword">while</span> (hi != clint_get_cycles_hi());<br><br>    <span class="hljs-keyword">return</span> ((u64)hi &lt;&lt; <span class="hljs-number">32</span>) | lo;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_64BIT */</span></span><br></code></pre></td></tr></table></figure><p><code>clint_get_cycles/clint_get_cycles_hi</code> 直接通过内存访问寄存器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_64BIT</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> clint_get_cycles()  readq_relaxed(clint_timer_val)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> clint_get_cycles()  readl_relaxed(clint_timer_val)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> clint_get_cycles_hi()   readl_relaxed(((u32 *)clint_timer_val) + 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><p>clockevent 是通过使能 <code>mie</code> 的 TIMER 中断，并向 <code>mtimecmp</code> 寄存器写入期望的计数值实现的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">clint_clock_next_event</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> delta,</span><br><span class="hljs-params">                   <span class="hljs-keyword">struct</span> clock_event_device *ce)</span><br>&#123;<br>    <span class="hljs-type">void</span> __iomem *r = clint_timer_cmp +<br>              cpuid_to_hartid_map(smp_processor_id());<br><br>    csr_set(CSR_IE, IE_TIE);<br>    writeq_relaxed(clint_get_cycles64() + delta, r);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="MMU-timer-riscv-c"><a href="#MMU-timer-riscv-c" class="headerlink" title="MMU timer-riscv.c"></a>MMU timer-riscv.c</h3><p>timer-riscv.c 驱动适用于有 MMU 的场景，内核运行在 S&#x2F;HS 模式下，通过 CONFIG_RISCV_TIMER 可以使能该驱动。和 timer-riscv.c 的驱动相比，本质上也是访问 <code>mtime</code> 和 <code>mtimecmp</code> 寄存器，不过由于 S 模式下无法直接访问它们，需要通过其他方式间接完成。</p><p>RV64 的 clocksource 是通过 csrr 直接读取 <code>time</code> 寄存器实现的；在 RV32 系统由于一条指令无法读完，需要分两次读取 <code>time</code> 和 <code>timeh</code>， 并考虑可能发生进位的情况。前面提到 <code>time</code> 和 <code>timeh</code> 这两个 CSR 是 <code>mtime</code> 寄存器的映射，因此频率与精度和 <code>mtime</code> 是一致的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_64BIT</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> u64 <span class="hljs-title function_">get_cycles64</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> get_cycles();<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* CONFIG_64BIT */</span></span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> u64 <span class="hljs-title function_">get_cycles64</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    u32 hi, lo;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        hi = get_cycles_hi();<br>        lo = get_cycles();<br>    &#125; <span class="hljs-keyword">while</span> (hi != get_cycles_hi());<br><br>    <span class="hljs-keyword">return</span> ((u64)hi &lt;&lt; <span class="hljs-number">32</span>) | lo;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_64BIT */</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">cycles_t</span> <span class="hljs-title function_">get_cycles</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> csr_read(CSR_TIME);<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> u32 <span class="hljs-title function_">get_cycles_hi</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> csr_read(CSR_TIMEH);<br>&#125;<br></code></pre></td></tr></table></figure><p>clockevent 则是通过 SBI 间接访问 <code>mtimecmp</code> 实现的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">riscv_clock_next_event</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> delta,</span><br><span class="hljs-params">        <span class="hljs-keyword">struct</span> clock_event_device *ce)</span><br>&#123;<br>    csr_set(CSR_IE, IE_TIE);<br>    sbi_set_timer(get_cycles64() + delta);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里以 OpenSBI 来分析，如果不支持 Sstc 扩展则调用在 SBI 中注册的 <code>timer_event_start</code> 函数写入 <code>mtimecmp</code>，这个需要具体平台自己去实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sbi_timer_event_start</span><span class="hljs-params">(u64 next_event)</span><br>&#123;<br>    sbi_pmu_ctr_incr_fw(SBI_PMU_FW_SET_TIMER);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Update the stimecmp directly if available. This allows</span><br><span class="hljs-comment">     * the older software to leverage sstc extension on newer hardware.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (sbi_hart_has_feature(sbi_scratch_thishart_ptr(), SBI_HART_HAS_SSTC)) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __riscv_xlen == 32</span><br>        csr_write(CSR_STIMECMP, next_event &amp; <span class="hljs-number">0xFFFFFFFF</span>);<br>        csr_write(CSR_STIMECMPH, next_event &gt;&gt; <span class="hljs-number">32</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        csr_write(CSR_STIMECMP, next_event);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timer_dev &amp;&amp; timer_dev-&gt;timer_event_start) &#123;<br>        timer_dev-&gt;timer_event_start(next_event);<br>        csr_clear(CSR_MIP, MIP_STIP);<br>    &#125;<br>    csr_set(CSR_MIE, MIP_MTIP);<br>&#125;<br></code></pre></td></tr></table></figure><p>在支持 Sstc 扩展后，可以直接访问 <code>stimecmp</code> 寄存器，避免通过 SBI 调用的方式产生的开销。社区已开展相关工作：<a href="https://lore.kernel.org/all/20220426185245.281182-1-atishp@rivosinc.com/">RISC-V: Prefer sstc extension if available</a>。</p><h3 id="KVM-vcpu-timer-c"><a href="#KVM-vcpu-timer-c" class="headerlink" title="KVM vcpu_timer.c"></a>KVM vcpu_timer.c</h3><p>在 VS 模式下读取 <code>time</code> 时，KVM 会返回真正的 <code>time</code> 加上 <code>htimedelta</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> u64 <span class="hljs-title function_">kvm_riscv_current_cycles</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kvm_guest_timer *gt)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> get_cycles64() + gt-&gt;time_delta;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 VS 模式下设置 <code>mtimecmp</code> 时，KVM 会开启一个已经创建好的高精度定时器，并把定时器的到期时间设置为写入 <code>mtimecmp</code> 值对应的 ns。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">kvm_riscv_vcpu_timer_next_event</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kvm_vcpu *vcpu, u64 ncycles)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_vcpu_timer</span> *<span class="hljs-title">t</span> =</span> &amp;vcpu-&gt;arch.timer;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_guest_timer</span> *<span class="hljs-title">gt</span> =</span> &amp;vcpu-&gt;kvm-&gt;arch.timer;<br>    u64 delta_ns;<br><br>    <span class="hljs-keyword">if</span> (!t-&gt;init_done)<br>        <span class="hljs-keyword">return</span> -EINVAL;<br><br>    kvm_riscv_vcpu_unset_interrupt(vcpu, IRQ_VS_TIMER);<br><br>    delta_ns = kvm_riscv_delta_cycles2ns(ncycles, gt, t);<br>    t-&gt;next_cycles = ncycles;<br>    hrtimer_start(&amp;t-&gt;hrt, ktime_set(<span class="hljs-number">0</span>, delta_ns), HRTIMER_MODE_REL);<br>    t-&gt;next_set = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在定时器到期后，KVM 会为 Guest 产生 TIMER 中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">enum</span> hrtimer_restart <span class="hljs-title function_">kvm_riscv_vcpu_hrtimer_expired</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> hrtimer *h)</span><br>&#123;<br>    u64 delta_ns;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_vcpu_timer</span> *<span class="hljs-title">t</span> =</span> container_of(h, <span class="hljs-keyword">struct</span> kvm_vcpu_timer, hrt);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_vcpu</span> *<span class="hljs-title">vcpu</span> =</span> container_of(t, <span class="hljs-keyword">struct</span> kvm_vcpu, arch.timer);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_guest_timer</span> *<span class="hljs-title">gt</span> =</span> &amp;vcpu-&gt;kvm-&gt;arch.timer;<br><br>    <span class="hljs-keyword">if</span> (kvm_riscv_current_cycles(gt) &lt; t-&gt;next_cycles) &#123;<br>        delta_ns = kvm_rizscv_delta_cycles2ns(t-&gt;next_cycles, gt, t);<br>        hrtimer_forward_now(&amp;t-&gt;hrt, ktime_set(<span class="hljs-number">0</span>, delta_ns));<br>        <span class="hljs-keyword">return</span> HRTIMER_RESTART;<br>    &#125;<br><br>    t-&gt;next_set = <span class="hljs-literal">false</span>;<br>    kvm_riscv_vcpu_set_interrupt(vcpu, IRQ_VS_TIMER);<br><br>    <span class="hljs-keyword">return</span> HRTIMER_NORESTART;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此 VS 模式设置时钟事件需要通过 SBI 调用进入 HS 模式然后再进入 M 模式，会产生较大的开销。同样，在支持 Sstc 扩展后，可以直接访问 <code>vstimecmp</code> 并产生 timer 中断，社区目前已经开展了相关的工作：<a href="https://lore.kernel.org/all/20220426185245.281182-4-atishp@rivosinc.com/">RISC-V: KVM: Support sstc extension</a>。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://github.com/riscv/riscv-platform-specs/blob/main/riscv-platform-spec.adoc/">RISC-V Platform</a></li><li><a href="https://riscv.org/technical/specifications/">RISC-V ISA Specification</a></li><li><a href="https://github.com/riscv/riscv-time-compare/releases/download/v0.5.4/Sstc.pdf">RISC-V “stimecmp &#x2F; vstimecmp” Extension</a></li><li>基于 FPGA 与 RISC-V 的嵌入式系统设计</li><li><a href="https://static.sched.com/hosted_files/osseu19/4e/Xvisor_Embedded_Hypervisor_for_RISCV_v5.pdf">RISC-V虚拟化扩展</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>kernel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kernel</tag>
      
      <tag>RISC-V</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
