<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Kprobes 使用与原理介绍</title>
    <link href="/2022/11/08/kprobe/"/>
    <url>/2022/11/08/kprobe/</url>
    
    <content type="html"><![CDATA[<p>.</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Kprobes</code> (kprobe and kretprobe)是一种Linux的调试机制，用于监控系统内部事件。你可以使用 <code>Kprobes</code> 来解决性能瓶颈、记录特定事件、跟踪问题等。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="kprobes-接口"><a href="#kprobes-接口" class="headerlink" title="kprobes 接口"></a>kprobes 接口</h3><p>内核源码samples目录下 <a href="https://github.com/torvalds/linux/blob/master/samples/kprobes/kprobe_example.c">kprobes&#x2F;kprobe_example.c</a> 提供了 <code>Kprobes</code> 测试用例。代码非常简单，主要配置了 <code>struct kprobe</code> 如下几个字段：</p><ul><li>symbol_name</li><li>offset</li><li>pre_handler</li><li>post_handler</li></ul><p>最后调用 <code>register_kprobe()</code> 注册定义的kprobe。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> register<span class="hljs-constructor">_kprobe(<span class="hljs-params">struct</span> <span class="hljs-params">kprobe</span> <span class="hljs-operator">*</span><span class="hljs-params">p</span>)</span><br>void unregister<span class="hljs-constructor">_kprobe(<span class="hljs-params">struct</span> <span class="hljs-params">kprobe</span> <span class="hljs-operator">*</span><span class="hljs-params">p</span>)</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kprobe</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span> <span class="hljs-title">hlist</span>;</span><br><br>    <span class="hljs-comment">/* list of kprobes for multi-handler support */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><br><br>    <span class="hljs-comment">/*count the number of times this probe was temporarily disarmed */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nmissed;<br><br>    <span class="hljs-comment">/* location of the probe point */</span><br>    <span class="hljs-type">kprobe_opcode_t</span> *addr;<br><br>    <span class="hljs-comment">/* Allow user to indicate symbol name of the probe point */</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *symbol_name;<br><br>    <span class="hljs-comment">/* Offset into the symbol */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset;<br><br>    <span class="hljs-comment">/* Called before addr is executed. */</span><br>    <span class="hljs-type">kprobe_pre_handler_t</span> pre_handler;<br><br>    <span class="hljs-comment">/* Called after addr is executed, unless... */</span><br>    <span class="hljs-type">kprobe_post_handler_t</span> post_handler;<br><br>    <span class="hljs-comment">/* Saved opcode (which has been replaced with breakpoint) */</span><br>    <span class="hljs-type">kprobe_opcode_t</span> opcode;<br><br>    <span class="hljs-comment">/* copy of the original instruction */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">arch_specific_insn</span> <span class="hljs-title">ainsn</span>;</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Indicates various status flags.</span><br><span class="hljs-comment">     * Protected by kprobe_mutex after this kprobe is registered.</span><br><span class="hljs-comment">     */</span><br>    u32 flags;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="kprobe-trace"><a href="#kprobe-trace" class="headerlink" title="kprobe trace"></a>kprobe trace</h3><p>使用方法和基于tracepoint的events类似. 不同的是Kprobes可以probe几乎所有函数（除了标注__kprobes&#x2F;nokprobe_inline  和被标记为 NOKPROBE_SYMBOL的函数），且在系统运行时能够动态添加&#x2F;删除。使用方法详见内核文档 <a href="https://www.kernel.org/doc/html/latest/trace/kprobetrace.html">kprobetrace</a>。主要是使用如下接口:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/sys/</span>kernel<span class="hljs-regexp">/debug/</span>tracing/kprobe_events<br><span class="hljs-regexp">/sys/</span>kernel<span class="hljs-regexp">/debug/</span>tracing<span class="hljs-regexp">/events/</span>kprobes<span class="hljs-regexp">/&lt;EVENT&gt;/</span>enable<br><span class="hljs-regexp">/sys/</span>kernel<span class="hljs-regexp">/debug/</span>tracing/dynamic_events<br></code></pre></td></tr></table></figure><h3 id="bpftrace"><a href="#bpftrace" class="headerlink" title="bpftrace"></a>bpftrace</h3><p>bpftrace使用很简单，详见 <a href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md#1-kprobekretprobe-dynamic-tracing-kernel-level">bpftrace guide</a>。例如，使用 <code>bpftrace</code> 通过  <code>kretprobe</code> 获取 <code>ktime_get</code> 返回的时间：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">sudo bpftrace -e <span class="hljs-symbol">&#x27;kretprobe</span>:ktime_get &#123; printf(<span class="hljs-string">&quot;time: %lld\n&quot;</span>, retval);&#125;&#x27;<br></code></pre></td></tr></table></figure><h2 id="Kprobes在arm64上的实现"><a href="#Kprobes在arm64上的实现" class="headerlink" title="Kprobes在arm64上的实现"></a>Kprobes在arm64上的实现</h2><p>kprobe 和 kretprobe 原理相似，因此本文只分析kprobe流程。</p><h3 id="register-kprobe流程"><a href="#register-kprobe流程" class="headerlink" title="register_kprobe流程"></a>register_kprobe流程</h3><ul><li><code>arch_prepare_kprobe() → arch_prepare_ss_slot()</code>, 拷贝probe点的指令（接下来需要替换probe位置的指令），调用 <code>get_insn_slot()</code> 获取一个slot，按照如下顺序排放：<ul><li>拷贝的probe点的指令</li><li><code>brk 0x6</code></li></ul></li><li><code>arm_kprobe() → arch_arm_kprobe()</code>，probe位置的指令替换为 <code>brk 0x4</code></li></ul><blockquote><p> <code>BRK #&lt;imm&gt;</code>，立即数 <code>imm</code> 会保存会在 <code>ESR_ELx.ISS</code>。<br><img src="/img/ESR_EL1.png" alt="ESR, From ARM Architecture Reference Manual D17.2.37"></p></blockquote><h3 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h3><p>1、执行到probe点后，由于已经替换成了 <code>brk 0x4</code>，执行后陷入el1 debug异常。 <code>call_break_hook</code> 根据 <code>ESR.ISS</code>（0x4）调用 <code>kprobe_breakpoint_handler</code>，然后再根据probe点的 <code>addr</code> 在kprobes的哈希链表找到注册的kprobe结构体，再调用结构体里的 <code>pre_handler()</code> 就完成了。调用栈如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">handler_pre</span>+<span class="hljs-number">0</span>x24/<span class="hljs-number">0</span>x70<span class="hljs-meta"> [kprobe_example]</span><br><span class="hljs-attribute">kprobe_breakpoint_handler</span>+<span class="hljs-number">0</span>xc0/<span class="hljs-number">0</span>x174<br><span class="hljs-attribute">call_break_hook</span>+<span class="hljs-number">0</span>x88/<span class="hljs-number">0</span>xa4<br><span class="hljs-attribute">brk_handler</span>+<span class="hljs-number">0</span>x2c/<span class="hljs-number">0</span>x70<br><span class="hljs-attribute">do_debug_exception</span>+<span class="hljs-number">0</span>x6c/<span class="hljs-number">0</span>x110<br><span class="hljs-attribute">el1_dbg</span>+<span class="hljs-number">0</span>x68/<span class="hljs-number">0</span>x80<br><span class="hljs-attribute">el1h_64_sync_handler</span>+<span class="hljs-number">0</span>xb4/<span class="hljs-number">0</span>xd0<br><span class="hljs-attribute">el1h_64_sync</span>+<span class="hljs-number">0</span>x64/<span class="hljs-number">0</span>x68<br></code></pre></td></tr></table></figure><p>2、执行完 <code>pre_handler()</code> 后，跳转到之前保存的slot执行，第一条指令就是原来probe点的指令，接下来执行下一条指令 <code>brk 0x6</code> 后再次陷入异常。流程和上文相似，只不过 <code>ESR.ISS</code> 变成了 0x6， 因此 <code>call_break_hook</code> 调用 <code>kprobe_breakpoint_ss_handler</code>，最后执行完 <code>handler_post()</code> 并退出异常，继续正常的代码流程。调用栈如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">handler_post</span>+<span class="hljs-number">0</span>x24/<span class="hljs-number">0</span>x50<span class="hljs-meta"> [kprobe_example]</span><br><span class="hljs-attribute">post_kprobe_handler</span>+<span class="hljs-number">0</span>x60/<span class="hljs-number">0</span>xb0<br><span class="hljs-attribute">kprobe_breakpoint_ss_handler</span>+<span class="hljs-number">0</span>x94/<span class="hljs-number">0</span>xa0<br><span class="hljs-attribute">call_break_hook</span>+<span class="hljs-number">0</span>x88/<span class="hljs-number">0</span>xa4<br><span class="hljs-attribute">brk_handler</span>+<span class="hljs-number">0</span>x2c/<span class="hljs-number">0</span>x70<br><span class="hljs-attribute">do_debug_exception</span>+<span class="hljs-number">0</span>x6c/<span class="hljs-number">0</span>x110<br><span class="hljs-attribute">el1_dbg</span>+<span class="hljs-number">0</span>x68/<span class="hljs-number">0</span>x80<br><span class="hljs-attribute">el1h_64_sync_handler</span>+<span class="hljs-number">0</span>xb4/<span class="hljs-number">0</span>xd0<br><span class="hljs-attribute">el1h_64_sync</span>+<span class="hljs-number">0</span>x64/<span class="hljs-number">0</span>x68<br></code></pre></td></tr></table></figure><h2 id="Jump-Optimization"><a href="#Jump-Optimization" class="headerlink" title="Jump Optimization"></a>Jump Optimization</h2><p>ToDo</p><h3 id="Safety-Check"><a href="#Safety-Check" class="headerlink" title="Safety Check"></a>Safety Check</h3><h3 id="Preparing-Detour-Buffer"><a href="#Preparing-Detour-Buffer" class="headerlink" title="Preparing Detour Buffer"></a>Preparing Detour Buffer</h3><h3 id="Pre-optimization"><a href="#Pre-optimization" class="headerlink" title="Pre-optimization"></a>Pre-optimization</h3><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://lwn.net/Articles/132196/">An introduction to KProbes</a></li><li><a href="https://blog.arstercz.com/introduction_to_linux_dynamic_tracing/">Linux 系统动态追踪技术介绍</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>kernel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kernel</tag>
      
      <tag>trace</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux youtube 频道归档</title>
    <link href="/2022/10/29/linux-channel/"/>
    <url>/2022/10/29/linux-channel/</url>
    
    <content type="html"><![CDATA[<p>归档Linux相关会议 youtube 频道，优秀的程序员应该具有国际视野 :-)</p><p><a href="https://www.youtube.com/c/LinuxPlumbersConference/videos">Linux Plumbers Conference</a></p><blockquote><p>Linux Plumbers Conference 2022 features tracts on system boot, kernel memory management, kernel testing, the Rust programming language, CPU isolation, eBPF, confidential computing, real-time and scheduling, toolchains, power management, Compute Express Link (CXL), and other exciting topics.</p></blockquote><p><a href="https://www.youtube.com/c/LinuxfoundationOrg">The Linux Foundation</a></p><blockquote><p>The Linux Foundation provides a neutral forum for collaboration and education by hosting Collaborative Projects, Linux conferences including LinuxCon, and generating original research and content that advances the understanding of Linux and collaborative software development.</p></blockquote><p><a href="https://www.youtube.com/c/Hupstream/videos">Kernel Recipes</a></p><blockquote><p>Informal conference about the Linux kernel in Paris – next edition, 1-3 june 2022</p></blockquote><p><a href="https://www.youtube.com/channel/UCt50fEvgrEuN9fvya8ujVzA/videos">Performance Summit</a></p><blockquote><p>Performance Summit events serve as a place for software performance enthusiasts and practitioners to meet and discuss challenges, research and possible solutions around delivering delightful and efficient software solutions.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>kernel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(ongoing) 理解 lockdep 中的 lock class</title>
    <link href="/2022/09/07/lockdep-design/"/>
    <url>/2022/09/07/lockdep-design/</url>
    
    <content type="html"><![CDATA[<h2 id="lock-class"><a href="#lock-class" class="headerlink" title="lock class"></a>lock class</h2><p>lockdep 跟踪基本单元并不是每个锁的实例，而是锁类（lock class），在 <a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">Runtime locking correctness validator</a> 这篇文章中 lockdep 作者 Ingo Molnar 解释了什么是锁类：</p><blockquote><p>A class of locks is a group of locks that are logically the same with respect to locking rules, even if the locks may have multiple (possibly tens of thousands of) instantiations. For example a lock in the inode struct is one class, while each inode has its own instantiation of that lock class.</p></blockquote><p>毫无疑问这种说法是准确的（毕竟是 Ingo 大佬），但是对于我这种小白来说未免过于抽象 :)。查阅代码后才理解了锁类的准确含义，以 spinlock 为例，在锁的初始化时定义了一个静态变量 __key，因此如果多个锁实例使用的 __key是同一个，那么它们就是同一个锁类，并采用哈希表来存储。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-keyword">define</span> raw_spin_lock_init(lock)                   \</span><br><span class="hljs-meta">do &#123;                                    \</span><br><span class="hljs-meta">    static struct lock_class_key __key;             \</span><br><span class="hljs-meta">                                    \</span><br><span class="hljs-meta">    __raw_spin_lock_init((lock), #lock, &amp;__key, LD_WAIT_SPIN);  \</span><br><span class="hljs-meta">&#125; while (0)</span><br></code></pre></td></tr></table></figure><p>以如下代码片段为例，如果打开lockdep功能后：</p><ul><li>xxx_function1()执行时 lockdep 会打印警告：[ INFO: possible recursive locking detected ] ，当然，这显然是一个误报，并不是真的会死锁。由于__key是静态定义的，因此只要锁初始化时的代码位置相同(正如 xxx_function1 中的st1.lock 和 st2.lock)，它们就是一个锁类。</li><li>xxx_function2() 则不会打印任何警告，因为 st1.lock 和 st2.lock 对应不同的 __key。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">st</span> &#123;</span><br><span class="hljs-type">spinlock_t</span>lock;<br>    <span class="hljs-type">int</span> some_var;<br>&#125;<br><br>xxx_function1() &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">st</span> <span class="hljs-title">st1</span>, <span class="hljs-title">st2</span>;</span><br><br>    xxx_init(&amp;st1);<br>    xxx_init(&amp;st2);<br><br>    recursive_locking(&amp;st1.lock, &amp;st2.lock);<br>&#125;<br><br>xxx_function2() &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">st</span> <span class="hljs-title">st1</span>, <span class="hljs-title">st2</span>;</span><br><br>spin_lock_init(&amp;st1.lock);<br>spin_lock_init(&amp;st2.lock);<br><br>    recursive_locking(&amp;st1.lock, &amp;st2.lock);<br><br>&#125;<br><br>xxx_init(<span class="hljs-keyword">struct</span> st *a)<br>&#123;<br>spin_lock_init(&amp;a-&gt;lock);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">recursive_locking</span><span class="hljs-params">(<span class="hljs-type">spinlock_t</span> *a1, <span class="hljs-type">spinlock_t</span> *a2)</span><br>&#123;<br>    spin_lock(a1);<br>    spin_lock(a2);<br><br>    spin_unlock(a2);<br>    spin_unlock(a1);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="lock-usage-state"><a href="#lock-usage-state" class="headerlink" title="lock usage state"></a>lock usage state</h2><p>待完善</p><h2 id="lockdep-检查规则"><a href="#lockdep-检查规则" class="headerlink" title="lockdep 检查规则"></a>lockdep 检查规则</h2><p>待完善</p><h2 id="lockdep-代码分析"><a href="#lockdep-代码分析" class="headerlink" title="lockdep 代码分析"></a>lockdep 代码分析</h2><p>待完善</p>]]></content>
    
    
    <categories>
      
      <category>kernel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kernel</tag>
      
      <tag>lock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>获取内核邮件列表补丁以及邮件</title>
    <link href="/2022/08/15/b4-workflow-tool/"/>
    <url>/2022/08/15/b4-workflow-tool/</url>
    
    <content type="html"><![CDATA[<p><a href="http://lore.kernel.org/">lore.kernel.org</a> 网站归档了 linux 内核社区的邮件，在上面可以看到社区最新的讨论以及各个模块的补丁，为了便于获取上面的补丁和邮件，社区开发了 b4 工具。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>以下两种方法都可以获取 b4 工具：</p><ul><li>通过 pip 安装<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo pip install b4<br></code></pre></td></tr></table></figure></li><li>直接从源码启动<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://git.kernel.org/pub/scm/utils/b4/b4.git<br></code></pre></td></tr></table></figure></li></ul><h2 id="获取补丁"><a href="#获取补丁" class="headerlink" title="获取补丁"></a>获取补丁</h2><p>在 lore.kernel.org 找到我们需要的补丁集，比如想要获取这组 rcu 补丁集：<br><a href="https://lore.kernel.org/all/20220831180759.GA2693289@paulmck-ThinkPad-P17-Gen-1/">https://lore.kernel.org/all/20220831180759.GA2693289@paulmck-ThinkPad-P17-Gen-1/</a><br>把链接中的message id (url 中间部分)放在 am 选项后即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./b4.sh am 20220831180759.GA2693289@paulmck-ThinkPad-P17-Gen-1<br></code></pre></td></tr></table></figure><p>同一个补丁集中不同补丁的 message id 不同，但任意一个 message id 都可以让 b4 工具获取到完整的补丁集。成功后能够获取到补丁封面 .cover 和 mbox 格式（ready to git-am）的补丁内容。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console">20220831_paulmck_miscellaneous_fixes_for_v6_1.cover<br>20220831_paulmck_miscellaneous_fixes_for_v6_1.mbx<br></code></pre></td></tr></table></figure><p>进入linux 源码仓，git am 20220831_paulmck_miscellaneous_fixes_for_v6_1.mbx 即可合入补丁。</p><h2 id="获取-mbox"><a href="#获取-mbox" class="headerlink" title="获取 mbox"></a>获取 mbox</h2><p>另一个实用的场景是：如果没有没有订阅内核邮件列表或者错过了某些邮件，又想要参与这个补丁的社区讨论。我们可以通过 b4 工具抓去对应的 mbox 文件后导入到邮箱软件中，之后便可以正常参与讨论交流了。<br>方法和上面一致，am 替换成 mbox 即可。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">./b4.<span class="hljs-keyword">sh</span> mbox 20220831180759.GA2693289@paulmck-ThinkPad-P17-<span class="hljs-keyword">Gen</span>-1<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>kernel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kernel</tag>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用 debootstrap 构建 Debian/Ubuntu 文件系统</title>
    <link href="/2022/07/24/qemu-debian/"/>
    <url>/2022/07/24/qemu-debian/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>构建根文件系统常见的方法有 busybox, buildroot, yocto 等， 对应的资料网络上都很丰富，缺点是功能过于简单或者步骤过于复杂。采用 Ubuntu&#x2F;Debian 文件系统是个不错的选择，通过 apt 能够复用 ubuntu&#x2F;debian 软件生态，自动解决软件依赖。debootstrap 是一个用来构建 Debian base 系统(根文件系统)的工具，通过 debootstrap 可以很轻松地构建出一个 Debian&#x2F;Ubuntu 文件系统。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>安装 qemu-system-aarch64</li><li>安装 qemu-user-static</li><li>安装 debootstrap</li><li>正确配置并编译好的内核镜像</li></ul><h2 id="文件系统构建"><a href="#文件系统构建" class="headerlink" title="文件系统构建"></a>文件系统构建</h2><p>首先创建一个 ext4 文件系统并挂载，512 MiB 大小就足够了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> tmp-rootfs<br>sudo <span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=rootfs-debian.ext4 bs=1MiB count=512<br>sudo mkfs.ext4 rootfs-debian.ext4<br>sudo mount rootfs-debian.ext4 tmp-rootfs<br></code></pre></td></tr></table></figure><p>debootstrap 简要用法如下，详细用法可查看 <code>man debootstrap</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">debootstrap [OPTION]... &lt;suite&gt; &lt;target&gt; &lt;mirror&gt;<br>debootstrap [OPTION] --second-stage<br></code></pre></td></tr></table></figure><ul><li>suite 是指版本代号，如 <a href="https://wiki.debian.org/DebianReleases#Production_Releases">debian</a> 的 buster 或者 <a href="https://wiki.ubuntu.com/Releases">ubuntu</a> 的 jammy，填第一个单词的小写就行了</li><li>target 是指目标架构，如 arm64</li><li>mirror 是指构建 Debian&#x2F;Ubuntu 的镜像源</li></ul><p>这里我们用华为的镜像源构建 Debian buster 版本 arm64 系统：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console">sudo debootstrap --verbose --arch=arm64 buster tmp-rootfs http://mirrors.huaweicloud.com/debian<br></code></pre></td></tr></table></figure><p>同样，如果想构建 Ubuntu 系统则修改 suite 和 mirror 即可：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console">sudo debootstrap --verbose --arch=arm64 jammy tmp-rootfs http://mirrors.huaweicloud.com/ubuntu-ports<br></code></pre></td></tr></table></figure><p>执行结束后就会在我们创建的 tmp-rootfs 目录生成所需要的 Debian 系统。</p><h2 id="文件系统配置"><a href="#文件系统配置" class="headerlink" title="文件系统配置"></a>文件系统配置</h2><p>文件系统构建完成后，我们还需要配置网络、安装软件，配置用户等。</p><p>首先拷贝之前安装的 qemu-static 工具到我们的文件系统，因为我们这里的 host 是 x86 架构，通过 host 配置系统时需要运行文件系统内的 arm64 架构的程序，需要 qemu-aarch64-static 对进行用户模式模拟。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console">sudo cp /usr/bin/qemu-aarch64-static tmp-rootfs/usr/bin<br></code></pre></td></tr></table></figure><p>之后 chroot 到文件系统：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console">sudo chroot tmp-rootfs<br></code></pre></td></tr></table></figure><p>按照个人需求创建用户和修改密码：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console">passwd<br>...<br></code></pre></td></tr></table></figure><p>同样按照个人需求安装软件：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console">apt install net-tools vim wget curl<br></code></pre></td></tr></table></figure><p>最后还需要配置网络，QMEU 网络配置详情查看 <a href="https://wiki.qemu.org/Documentation/Networking">QEMU Networking</a>，这里配置最简单的用户模式网卡。<br><img src="/img/Slirp_concept.png" alt="QEMU User Networking"></p><p>同时具体配置方法和系统也相关，以 Debian buster 为例，网络是由 <code>/etc/network/interfaces</code> 文件配置的，将以下内容写入该文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">auto lo<br>iface lo inet loopback<br><br>auto eth0<br>iface eth0 inet dhcp<br>  wait-delay 15<br>  hostname $(hostname)<br></code></pre></td></tr></table></figure><p>对于 QEMU 用户模式网卡，需要配置 DNS 服务器为 10.0.2.3，将以下内容写入 <code>/etc/resolv.conf</code>。注意：此时 DNS 服务器地址和 host 不一样了，因此在 host 上 chroot 后安装软件会失败。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;nameserver 10.0.2.3&quot;</span> &gt; /etc/resolv.conf<br></code></pre></td></tr></table></figure><p>最后 umount 文件系统就大功告成了 :)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo umount tmp-rootfs<br></code></pre></td></tr></table></figure><h2 id="运行-QEMU"><a href="#运行-QEMU" class="headerlink" title="运行 QEMU"></a>运行 QEMU</h2><p>通过如下命令启动 QEMU 环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">qemu-system-aarch64 -M virt -cpu cortex-a53 -nographic -smp 8 -kernel Image \<br>    -append <span class="hljs-string">&quot;rootwait root=/dev/vda rw console=ttyAMA0&quot;</span> \<br>    -netdev user,<span class="hljs-built_in">id</span>=eth0,hostfwd=tcp::17777-:22 -device virtio-net-device,netdev=eth0 \<br>    -drive file=rootfs-debian.ext4,<span class="hljs-keyword">if</span>=none,format=raw,<span class="hljs-built_in">id</span>=hd0 -device virtio-blk-device,drive=hd0 <br></code></pre></td></tr></table></figure><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="Ubuntu-jammy-网络异常"><a href="#Ubuntu-jammy-网络异常" class="headerlink" title="Ubuntu jammy 网络异常"></a>Ubuntu jammy 网络异常</h3><p>使用 Ubuntu jammy 发现通过 <code>netplan</code> 配置网络不成功，每次启动网卡没有 up。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">network:</span><br>  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">renderer:</span> <span class="hljs-string">NetworkManager</span><br>  <span class="hljs-attr">ethernets:</span><br>    <span class="hljs-attr">eth0:</span><br>      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>怀疑和 <code>NetworkManager.service</code> 没有起来相关，同时系统 <code>systemd-resolved.service</code> 会自动生成错误的 DNS 地址（和 host 的相同），目前解决办法只能手动配置 DNS ，网卡和路由。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">echo</span> <span class="hljs-string">&quot;nameserver 10.0.2.3&quot;</span> &gt; /etc/resolv.conf<br>ifconfig eth0 <span class="hljs-number">10.0.2.15</span>  netmask <span class="hljs-number">255.255.255.0</span><br>route add default gw <span class="hljs-number">10.0.2.2</span><br></code></pre></td></tr></table></figure><p>更新：安装 nmcli 后问题解决（Ubuntu 太坑了，这种核心软件没有提前安装好），使用方法可以看看这篇文章 <a href="https://www.liquidweb.com/kb/how-to-install-and-configure-nmcli/">How to Install and Configure Nmcli</a></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">apt <span class="hljs-keyword">install</span> network-manager<br></code></pre></td></tr></table></figure><p>然后用 <code>netplan</code> 配置网卡</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">vim</span> /etc/netplan/<span class="hljs-number">01</span>-network-manager-<span class="hljs-literal">all</span>.yaml<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">network:</span><br>  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">renderer:</span> <span class="hljs-string">NetworkManager</span><br>  <span class="hljs-attr">ethernets:</span><br>    <span class="hljs-attr">eth0:</span><br>      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">nameservers:</span><br>        <span class="hljs-attr">addresses:</span> [<span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.3</span>]<br><br></code></pre></td></tr></table></figure><h2 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h2><ul><li>完善 netplan 方式配置网卡</li><li>完善 nmcli 使用方法</li><li>写一篇文章整理 QEMU 网卡配置，包括tap&#x2F;tun 模式网卡配置</li><li>QEMU 使用其他模式网卡时 debian&#x2F;ubuntu 网络怎么配置</li><li>Linux kernel tap&#x2F;tun 原理分析</li><li>将构建过程整理成脚本，提交到 <a href="https://github.com/yuliao0214/qemu-vm">qemu-vm</a> 仓库</li></ul>]]></content>
    
    
    <categories>
      
      <category>QEMU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>編集者の神: VIM 总结</title>
    <link href="/2022/06/03/vim/"/>
    <url>/2022/06/03/vim/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>总结个人常用的操作，能够覆盖绝大多数场景，除了怎么退出vim(<a href="https://www.runoob.com/linux/linux-vim.html">菜鸟教程</a>)。</p><h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><ul><li><code>Ctrl + d</code> &amp; <code>ctrl + u</code> 向下&#x2F;向上翻半页</li><li><code>h</code> <code>j</code> <code>k</code> <code>l</code> &#x3D; <code>←</code> <code>↓</code> <code>↑</code> <code>→</code></li><li><code>gg</code> &amp; <code>G</code> 跳到第一行&#x2F;最后一行</li><li><code>H</code>, <code>M</code>, <code>L</code>, 跳到当前屏幕的第一行(High)，中间(Middle)，最后一行(Low)</li><li><code>b</code>, <code>w</code> 以一个word为单位向前&#x2F;先后移动光标</li></ul><h2 id="光标选中"><a href="#光标选中" class="headerlink" title="光标选中"></a>光标选中</h2><p>按下按键后松开就进入了可视模式，然后用上面提到的光标移动按键选中需要的文本。可视模式分为一下三种，看图就明白了：</p><ul><li><p>字符模式：v<br><img src="/img/visual.png" alt="visual"></p></li><li><p>行模式：V<br><img src="/img/visual-line.png" alt="visual"></p></li><li><p>块模式：ctrl+v<br><img src="/img/visual-block.png" alt="visual"></p></li></ul><blockquote><p>Tip: <code>viw</code> 选中一个单词</p></blockquote><h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><p>结合前面提到的光标选中和光标移动后就可以复制、删除和粘贴文本了</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul><li><code>i</code> &amp; <code>a</code> 当前光标输入和当前光标下一个位置输入</li><li><code>o</code> &amp; <code>O</code> 在下一行&#x2F;上一行处输入</li><li><code>r</code> 替换光标字符</li><li><code>I</code> 配合 visual-block 模式可以实现多行编辑</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li><code>x</code> 删除字符</li><li><code>dd</code> 删除行</li></ul><blockquote><p>Tip: <code>diw</code> 删除一个单词</p></blockquote><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul><li><code>y</code> 复制已选中的文本</li><li><code>yy</code> 复制光标所在行</li></ul><h3 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h3><p><code>p</code> 粘贴到光标后<br><code>P</code> 粘贴到光标后</p><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><ul><li><code>u</code> 撤销上一次操作</li><li><code>Ctrl + r</code> 和上面相反的效果</li></ul><h2 id="多窗口编辑"><a href="#多窗口编辑" class="headerlink" title="多窗口编辑"></a>多窗口编辑</h2><ul><li>vim -O file1 file2</li><li><code>Crtl + w + v</code>复制当前窗口（左右分割）</li><li><code>Crtl + w + c</code>关闭当前窗口</li><li><code>Ctrl + w + w</code>在多窗口间切换</li><li>:e file 更改当前文件</li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul><li>ctags &amp; cscope 跳转</li><li>NERDTreeToggle 显示目录</li><li>taglist 显示tag</li><li>gruvbox 很好看的主题，有dark&#x2F;light两种颜色</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>使用管道（Pipe）<br>cmd | vim -</p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V timer 在 Linux 中的实现</title>
    <link href="/2022/05/01/riscv-linux-timer/"/>
    <url>/2022/05/01/riscv-linux-timer/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Author:  Yu Liao <a href="mailto:&#121;&#117;&#108;&#x69;&#97;&#111;&#x30;&#x32;&#x31;&#52;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;">&#121;&#117;&#108;&#x69;&#97;&#111;&#x30;&#x32;&#x31;&#52;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;</a><br>Revisor: lzufalcon <a href="mailto:&#x66;&#97;&#108;&#x63;&#x6f;&#110;&#64;&#x74;&#105;&#110;&#x79;&#108;&#97;&#x62;&#x2e;&#x6f;&#114;&#x67;">&#x66;&#97;&#108;&#x63;&#x6f;&#110;&#64;&#x74;&#105;&#110;&#x79;&#108;&#97;&#x62;&#x2e;&#x6f;&#114;&#x67;</a><br>Project: <a href="https://gitee.com/tinylab/riscv-linux">RISC-V Linux 内核剖析</a></p></blockquote><h2 id="RISC-V-timer-相关寄存器"><a href="#RISC-V-timer-相关寄存器" class="headerlink" title="RISC-V timer 相关寄存器"></a>RISC-V timer 相关寄存器</h2><h3 id="mtime-amp-mtimecmp-寄存器"><a href="#mtime-amp-mtimecmp-寄存器" class="headerlink" title="mtime &amp; mtimecmp 寄存器"></a>mtime &amp; mtimecmp 寄存器</h3><p>按照 RISC-V 定义，系统需要提供两个 64 位的 M 模式寄存器 <code>mtime</code> 和 <code>mtimecmp</code>，并通过 MMIO 方式映射到地址空间。</p><p><code>mtime</code> 需要以固定的频率递增，并在发生溢出时回绕。当 <code>mtime</code> 大于或等于 <code>mtimecmp</code> 时，由核内中断控制器 (CLINT, Core-Local Interrupt Controller) 产生 timer 中断。中断的使能由 <code>mie</code> 寄存器中的 <code>MTIE</code> 和 <code>STIE</code> 位控制，<code>mip</code> 中的 <code>MPIE</code> 和 <code>SPIE</code> 则指示了 timer 中断是否处于 pending。在 RV32 中读取 <code>mtimecmp</code> 结果为低 32 位， <code>mtimecmp</code> 的高 32 位需要读取 <code>mtimecmph</code> 得到。</p><p>在 <a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">RISC-V 特权 ISA 规范</a> 的 3.2.1 Machine Timer Registers (mtime and mtimecmp) 中详细介绍了这部分。</p><h3 id="time-CSR"><a href="#time-CSR" class="headerlink" title="time CSR"></a>time CSR</h3><p>RISC-V 还定义了一个 64 位非特权 CSR 寄存器 <code>time</code>，<code>time</code> 计数器是前面提到的 <code>mtime</code> 的只读映射。同样，在 RV32 中 <code>timeh</code> CSR 是 <code>mtime</code> 高 32 位的只读映射，对于 M 模式和 S 模式它们都是可读写的。</p><p>在 <a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">RISC-V 特权 ISA 规范</a> 的 2.2 CSR Listing 和 3.1.11 Machine Counter-Enable Register (mcounteren) 可以找到这块的规范。</p><h3 id="htimedelta-amp-htimedeltah-寄存器"><a href="#htimedelta-amp-htimedeltah-寄存器" class="headerlink" title="htimedelta &amp; htimedeltah 寄存器"></a>htimedelta &amp; htimedeltah 寄存器</h3><p>在增加虚拟化扩展以后，特权模式会发生一定变化，如下图（来源于参考文档 5）所示：</p><p><img src="/img/riscv-privilege-mode.png" alt="RISC-V 虚拟化特权模式"></p><p>相应地，timer 支持也进行了如下扩展：</p><p><code>htimedelta</code> 和 <code>htimedeltah</code> 是 Hypervisor 扩展里的 CSR，在 VS&#x2F;VU 模式下读取 <code>time</code> 结果是真正的 host 中的 <code>time</code> 加上 <code>htimedelta</code>。同样的，对于 RV32 <code>htimedelta</code> 保存了低 32 位，高 32 位保存在 <code>htimedeltah</code>。</p><p>在 <a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">RISC-V 特权 ISA 规范</a> 的 8.2.7  Hypervisor Time Delta Registers (htimedelta, htimedeltah) 中详细介绍了这部分。</p><h3 id="Sstc-扩展"><a href="#Sstc-扩展" class="headerlink" title="Sstc 扩展"></a>Sstc 扩展</h3><p>由于 <code>mtimecmp</code> 只能在 M 模式下访问，对于 S&#x2F;HS 模式下的内核和 VU&#x2F;VS 模式下的虚拟机需要通过 SBI 才能访问，会造成较大的中断延迟和性能开销。为了解决这一问题，RISC-V 新增了 Sstc 拓展支持（已批准但尚未最终集成到规范中）。</p><p>Sstc 扩展为 HS 模式和 VS 模式分别新增了 <code>stimecmp</code> 和 <code>vstimecmp</code> 寄存器，当 $time &gt;&#x3D; stimecmp$  (HS)或 $time+htimedelta &gt;&#x3D; vstimecmp$  (VS)时会产生 timer 中断，不再需要通过 SBI 陷入其他模式。</p><p>详见 <a href="https://github.com/riscv/riscv-time-compare/releases/download/v0.5.4/Sstc.pdf">RISC-V “stimecmp &#x2F; vstimecmp” 扩展</a> 。</p><h2 id="Linux-timer-实现"><a href="#Linux-timer-实现" class="headerlink" title="Linux timer 实现"></a>Linux timer 实现</h2><p>Linux 将底层时钟硬件抽象为两类设备：clockevent 和 clocksource，前者用来在未来指定的时间产生中断，通常用作定时器；后者则用于维护自系统启动以来所经过的时间。</p><p>当前 Linux 为 RISC-V 根据内核运行模式实现了两套驱动，代码路径为 drivers&#x2F;clocksource&#x2F;timer-riscv.c 和 drivers&#x2F;clocksource&#x2F;timer-clint.c。</p><p>本文代码基于最新的 Linux v5.18-rc4 和 OpenSBI v1.0，截止目前 Linux 对 Sstc 扩展的支持还没有合入主线内核，社区已有相关补丁：<a href="https://lkml.org/lkml/2022/3/4/1175">Add Sstc extension support</a>。</p><p><code>mtime</code> 频率由设备树 CPU 节点中的 timebase-frequency 定义，不同平台都各不相同，如 Kendryte K210 的频率是 7.8 MHz，平头哥 C910 的频率是 3 MHz，SiFive Unmatched A00 频率为 1 MHz。</p><h3 id="NoMMU-timer-clint-c"><a href="#NoMMU-timer-clint-c" class="headerlink" title="NoMMU timer-clint.c"></a>NoMMU timer-clint.c</h3><p>timer-clint.c 驱动适用于 NoMMU 系统，内核运行在 M 模式下，通过 CONFIG_CLINT_TIMER 使能该驱动。RV64 下 clocksource 是通过直接读取 <code>mtime</code> 寄存器实现的，RV32 系统需要分两次读取，并需要考虑产生进位的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_64BIT</span><br><span class="hljs-type">static</span> u64 notrace <span class="hljs-title function_">clint_get_cycles64</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> clint_get_cycles();<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* CONFIG_64BIT */</span></span><br><span class="hljs-type">static</span> u64 notrace <span class="hljs-title function_">clint_get_cycles64</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    u32 hi, lo;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        hi = clint_get_cycles_hi();<br>        lo = clint_get_cycles();<br>    &#125; <span class="hljs-keyword">while</span> (hi != clint_get_cycles_hi());<br><br>    <span class="hljs-keyword">return</span> ((u64)hi &lt;&lt; <span class="hljs-number">32</span>) | lo;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_64BIT */</span></span><br></code></pre></td></tr></table></figure><p><code>clint_get_cycles/clint_get_cycles_hi</code> 直接通过内存访问寄存器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_64BIT</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> clint_get_cycles()  readq_relaxed(clint_timer_val)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> clint_get_cycles()  readl_relaxed(clint_timer_val)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> clint_get_cycles_hi()   readl_relaxed(((u32 *)clint_timer_val) + 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><p>clockevent 是通过使能 <code>mie</code> 的 TIMER 中断，并向 <code>mtimecmp</code> 寄存器写入期望的计数值实现的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">clint_clock_next_event</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> delta,</span><br><span class="hljs-params">                   <span class="hljs-keyword">struct</span> clock_event_device *ce)</span><br>&#123;<br>    <span class="hljs-type">void</span> __iomem *r = clint_timer_cmp +<br>              cpuid_to_hartid_map(smp_processor_id());<br><br>    csr_set(CSR_IE, IE_TIE);<br>    writeq_relaxed(clint_get_cycles64() + delta, r);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="MMU-timer-riscv-c"><a href="#MMU-timer-riscv-c" class="headerlink" title="MMU timer-riscv.c"></a>MMU timer-riscv.c</h3><p>timer-riscv.c 驱动适用于有 MMU 的场景，内核运行在 S&#x2F;HS 模式下，通过 CONFIG_RISCV_TIMER 可以使能该驱动。和 timer-riscv.c 的驱动相比，本质上也是访问 <code>mtime</code> 和 <code>mtimecmp</code> 寄存器，不过由于 S 模式下无法直接访问它们，需要通过其他方式间接完成。</p><p>RV64 的 clocksource 是通过 csrr 直接读取 <code>time</code> 寄存器实现的；在 RV32 系统由于一条指令无法读完，需要分两次读取 <code>time</code> 和 <code>timeh</code>， 并考虑可能发生进位的情况。前面提到 <code>time</code> 和 <code>timeh</code> 这两个 CSR 是 <code>mtime</code> 寄存器的映射，因此频率与精度和 <code>mtime</code> 是一致的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_64BIT</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> u64 <span class="hljs-title function_">get_cycles64</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> get_cycles();<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* CONFIG_64BIT */</span></span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> u64 <span class="hljs-title function_">get_cycles64</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    u32 hi, lo;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        hi = get_cycles_hi();<br>        lo = get_cycles();<br>    &#125; <span class="hljs-keyword">while</span> (hi != get_cycles_hi());<br><br>    <span class="hljs-keyword">return</span> ((u64)hi &lt;&lt; <span class="hljs-number">32</span>) | lo;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_64BIT */</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">cycles_t</span> <span class="hljs-title function_">get_cycles</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> csr_read(CSR_TIME);<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> u32 <span class="hljs-title function_">get_cycles_hi</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> csr_read(CSR_TIMEH);<br>&#125;<br></code></pre></td></tr></table></figure><p>clockevent 则是通过 SBI 间接访问 <code>mtimecmp</code> 实现的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">riscv_clock_next_event</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> delta,</span><br><span class="hljs-params">        <span class="hljs-keyword">struct</span> clock_event_device *ce)</span><br>&#123;<br>    csr_set(CSR_IE, IE_TIE);<br>    sbi_set_timer(get_cycles64() + delta);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里以 OpenSBI 来分析，如果不支持 Sstc 扩展则调用在 SBI 中注册的 <code>timer_event_start</code> 函数写入 <code>mtimecmp</code>，这个需要具体平台自己去实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sbi_timer_event_start</span><span class="hljs-params">(u64 next_event)</span><br>&#123;<br>    sbi_pmu_ctr_incr_fw(SBI_PMU_FW_SET_TIMER);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Update the stimecmp directly if available. This allows</span><br><span class="hljs-comment">     * the older software to leverage sstc extension on newer hardware.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (sbi_hart_has_feature(sbi_scratch_thishart_ptr(), SBI_HART_HAS_SSTC)) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __riscv_xlen == 32</span><br>        csr_write(CSR_STIMECMP, next_event &amp; <span class="hljs-number">0xFFFFFFFF</span>);<br>        csr_write(CSR_STIMECMPH, next_event &gt;&gt; <span class="hljs-number">32</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        csr_write(CSR_STIMECMP, next_event);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timer_dev &amp;&amp; timer_dev-&gt;timer_event_start) &#123;<br>        timer_dev-&gt;timer_event_start(next_event);<br>        csr_clear(CSR_MIP, MIP_STIP);<br>    &#125;<br>    csr_set(CSR_MIE, MIP_MTIP);<br>&#125;<br></code></pre></td></tr></table></figure><p>在支持 Sstc 扩展后，可以直接访问 <code>stimecmp</code> 寄存器，避免通过 SBI 调用的方式产生的开销。社区已开展相关工作：<a href="https://lore.kernel.org/all/20220426185245.281182-1-atishp@rivosinc.com/">RISC-V: Prefer sstc extension if available</a>。</p><h3 id="KVM-vcpu-timer-c"><a href="#KVM-vcpu-timer-c" class="headerlink" title="KVM vcpu_timer.c"></a>KVM vcpu_timer.c</h3><p>在 VS 模式下读取 <code>time</code> 时，KVM 会返回真正的 <code>time</code> 加上 <code>htimedelta</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> u64 <span class="hljs-title function_">kvm_riscv_current_cycles</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kvm_guest_timer *gt)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> get_cycles64() + gt-&gt;time_delta;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 VS 模式下设置 <code>mtimecmp</code> 时，KVM 会开启一个已经创建好的高精度定时器，并把定时器的到期时间设置为写入 <code>mtimecmp</code> 值对应的 ns。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">kvm_riscv_vcpu_timer_next_event</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kvm_vcpu *vcpu, u64 ncycles)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_vcpu_timer</span> *<span class="hljs-title">t</span> =</span> &amp;vcpu-&gt;arch.timer;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_guest_timer</span> *<span class="hljs-title">gt</span> =</span> &amp;vcpu-&gt;kvm-&gt;arch.timer;<br>    u64 delta_ns;<br><br>    <span class="hljs-keyword">if</span> (!t-&gt;init_done)<br>        <span class="hljs-keyword">return</span> -EINVAL;<br><br>    kvm_riscv_vcpu_unset_interrupt(vcpu, IRQ_VS_TIMER);<br><br>    delta_ns = kvm_riscv_delta_cycles2ns(ncycles, gt, t);<br>    t-&gt;next_cycles = ncycles;<br>    hrtimer_start(&amp;t-&gt;hrt, ktime_set(<span class="hljs-number">0</span>, delta_ns), HRTIMER_MODE_REL);<br>    t-&gt;next_set = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在定时器到期后，KVM 会为 Guest 产生 TIMER 中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">enum</span> hrtimer_restart <span class="hljs-title function_">kvm_riscv_vcpu_hrtimer_expired</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> hrtimer *h)</span><br>&#123;<br>    u64 delta_ns;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_vcpu_timer</span> *<span class="hljs-title">t</span> =</span> container_of(h, <span class="hljs-keyword">struct</span> kvm_vcpu_timer, hrt);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_vcpu</span> *<span class="hljs-title">vcpu</span> =</span> container_of(t, <span class="hljs-keyword">struct</span> kvm_vcpu, arch.timer);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_guest_timer</span> *<span class="hljs-title">gt</span> =</span> &amp;vcpu-&gt;kvm-&gt;arch.timer;<br><br>    <span class="hljs-keyword">if</span> (kvm_riscv_current_cycles(gt) &lt; t-&gt;next_cycles) &#123;<br>        delta_ns = kvm_rizscv_delta_cycles2ns(t-&gt;next_cycles, gt, t);<br>        hrtimer_forward_now(&amp;t-&gt;hrt, ktime_set(<span class="hljs-number">0</span>, delta_ns));<br>        <span class="hljs-keyword">return</span> HRTIMER_RESTART;<br>    &#125;<br><br>    t-&gt;next_set = <span class="hljs-literal">false</span>;<br>    kvm_riscv_vcpu_set_interrupt(vcpu, IRQ_VS_TIMER);<br><br>    <span class="hljs-keyword">return</span> HRTIMER_NORESTART;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此 VS 模式设置时钟事件需要通过 SBI 调用进入 HS 模式然后再进入 M 模式，会产生较大的开销。同样，在支持 Sstc 扩展后，可以直接访问 <code>vstimecmp</code> 并产生 timer 中断，社区目前已经开展了相关的工作：<a href="https://lore.kernel.org/all/20220426185245.281182-4-atishp@rivosinc.com/">RISC-V: KVM: Support sstc extension</a>。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://github.com/riscv/riscv-platform-specs/blob/main/riscv-platform-spec.adoc/">RISC-V Platform</a></li><li><a href="https://riscv.org/technical/specifications/">RISC-V ISA Specification</a></li><li><a href="https://github.com/riscv/riscv-time-compare/releases/download/v0.5.4/Sstc.pdf">RISC-V “stimecmp &#x2F; vstimecmp” Extension</a></li><li>基于 FPGA 与 RISC-V 的嵌入式系统设计</li><li><a href="https://static.sched.com/hosted_files/osseu19/4e/Xvisor_Embedded_Hypervisor_for_RISCV_v5.pdf">RISC-V虚拟化扩展</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>kernel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kernel</tag>
      
      <tag>RISC-V</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
